<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Henry Techie</title><link>https://namanh11611.github.io/tags/git/</link><description>Recent content in Git on Henry Techie</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 08 Sep 2024 00:00:00 +0700</lastBuildDate><atom:link href="https://namanh11611.github.io/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>Gitflow, GitHub Flow, GitLab Flow, Trunk-Based Development: Which Git Branching Strategy is Right for You?</title><link>https://namanh11611.github.io/p/git-branching-strategy/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0700</pubDate><guid>https://namanh11611.github.io/p/git-branching-strategy/</guid><description>&lt;img src="https://namanh11611.github.io/p/git-branching-strategy/strategy.jpg" alt="Featured image of post Gitflow, GitHub Flow, GitLab Flow, Trunk-Based Development: Which Git Branching Strategy is Right for You?" />&lt;p>&lt;em>Photo by &lt;a class="link" href="https://unsplash.com/@felix_mittermeier?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Felix Mittermeier&lt;/a> on &lt;a class="link" href="https://unsplash.com/photos/pieces-dechecs-sur-lechiquier-nAjil1z3eLk?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Unsplash&lt;/a>&lt;/em>&lt;/p>
&lt;p>&lt;strong>Git Branching Strategy&lt;/strong> refers to the way we &lt;strong>create branches&lt;/strong>, &lt;strong>merge branches&lt;/strong>, and decide which branches are used for releases.&lt;/p>
&lt;p>When starting a project, beyond setting up the environment and building a solid codebase, selecting the right &lt;strong>Git Branching Strategy&lt;/strong> is crucial. A wrong choice can lead to significant challenges. The right strategy helps the team &lt;strong>manage and maintain source code effectively&lt;/strong>, &lt;strong>reduce conflict resolution time&lt;/strong>, and ensure &lt;strong>production code remains stable&lt;/strong>.&lt;/p>
&lt;p>Over time, various strategies have emerged. This article explores some popular &lt;strong>Git Branching Strategies&lt;/strong> like &lt;strong>Gitflow&lt;/strong>, &lt;strong>GitHub Flow&lt;/strong>, &lt;strong>GitLab Flow&lt;/strong>, and &lt;strong>Trunk-Based Development&lt;/strong>. Finally, we’ll discuss how to choose the right strategy for your project.&lt;/p>
&lt;h1 id="gitflow">Gitflow
&lt;/h1>&lt;p>&lt;a class="link" href="https://nvie.com/posts/a-successful-git-branching-model" target="_blank" rel="noopener"
>&lt;strong>Gitflow&lt;/strong>&lt;/a>, introduced by &lt;a class="link" href="https://nvie.com/about" target="_blank" rel="noopener"
>&lt;strong>Vincent Driessen&lt;/strong>&lt;/a>, is well-suited for projects with clear and complex release cycles. &lt;strong>Gitflow&lt;/strong> uses multiple branch types to manage the development and release phases.&lt;/p>
&lt;p>&lt;img src="https://nvie.com/img/git-model@2x.png"
loading="lazy"
alt="Gitflow"
>&lt;/p>
&lt;p>In this flow, there are two main branches: &lt;strong>master&lt;/strong> and &lt;strong>develop&lt;/strong>. The &lt;strong>master&lt;/strong> branch contains stable code ready for release, while &lt;strong>develop&lt;/strong> contains the latest changes for the next release. It’s the main branch for feature integration.&lt;/p>
&lt;p>Additionally, there are &lt;strong>feature&lt;/strong> branches that are &lt;code>checkout&lt;/code> from &lt;strong>develop&lt;/strong> and used to develop new features. Once completed, they are &lt;code>merge&lt;/code> back into &lt;strong>develop&lt;/strong>.&lt;/p>
&lt;p>When ready for release, a branch is checked out from &lt;strong>develop&lt;/strong> to a &lt;strong>release&lt;/strong> branch with the corresponding version to prepare for the release. Bug fixes can be added as commits on this branch. Once finalized, the &lt;strong>release&lt;/strong> branch is &lt;code>merge&lt;/code> into both &lt;strong>master&lt;/strong> and &lt;strong>develop&lt;/strong> to keep the two main branches updated.&lt;/p>
&lt;p>Finally, there are &lt;strong>hotfix&lt;/strong> branches. When production code encounters a critical bug that needs an immediate fix, a &lt;strong>hotfix&lt;/strong> branch is &lt;code>checkout&lt;/code> from &lt;strong>master&lt;/strong> for the fix. Similar to &lt;strong>release&lt;/strong> branches, &lt;strong>hotfix&lt;/strong> branches must also be &lt;code>merge&lt;/code> into both &lt;strong>master&lt;/strong> and &lt;strong>develop&lt;/strong>.&lt;/p>
&lt;h2 id="advantages">Advantages
&lt;/h2>&lt;ul>
&lt;li>Provides a clear structure, ideal for large projects.&lt;/li>
&lt;li>Efficiently manages development and release phases with versioned &lt;strong>release&lt;/strong> branches.&lt;/li>
&lt;li>&lt;strong>Hotfix&lt;/strong> branches allow quick fixes without disrupting ongoing development.&lt;/li>
&lt;/ul>
&lt;h2 id="disadvantages">Disadvantages
&lt;/h2>&lt;ul>
&lt;li>Complex and requires multiple branches and merges. For example, each &lt;strong>release&lt;/strong> or &lt;strong>hotfix&lt;/strong> branch needs to be merged into both &lt;strong>master&lt;/strong> and &lt;strong>develop&lt;/strong>.&lt;/li>
&lt;li>Unsuitable for projects requiring &lt;strong>CI/CD&lt;/strong>.&lt;/li>
&lt;li>Challenging for small teams due to its cumbersome nature.&lt;/li>
&lt;/ul>
&lt;h1 id="github-flow">GitHub Flow
&lt;/h1>&lt;p>&lt;a class="link" href="https://docs.github.com/en/get-started/using-github/github-flow" target="_blank" rel="noopener"
>&lt;strong>GitHub Flow&lt;/strong>&lt;/a> is a lightweight, simple strategy ideal for &lt;strong>CI/CD&lt;/strong> and commonly used in open-source projects or small teams.&lt;/p>
&lt;p>&lt;img src="https://namanh11611.github.io/p/git-branching-strategy/github_flow.png"
width="3532"
height="3840"
srcset="https://namanh11611.github.io/p/git-branching-strategy/github_flow_hu1268168611847259529.png 480w, https://namanh11611.github.io/p/git-branching-strategy/github_flow_hu9175722533628964805.png 1024w"
loading="lazy"
alt="GitHub Flow"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="220px"
>&lt;/p>
&lt;p>Unlike Gitflow, it has a single main branch, &lt;strong>main&lt;/strong>, which contains thoroughly tested and stable code ready for production.&lt;/p>
&lt;p>Features are developed in &lt;strong>feature&lt;/strong> branches, tested, reviewed, and merged into &lt;strong>main&lt;/strong> via pull requests.&lt;/p>
&lt;h2 id="advantages-1">Advantages
&lt;/h2>&lt;ul>
&lt;li>Simple and easy to understand, making it quick to implement.&lt;/li>
&lt;li>Perfect for &lt;strong>CI/CD&lt;/strong> workflows, ensuring the &lt;strong>main&lt;/strong> branch is always deployable.&lt;/li>
&lt;li>Fewer branches mean reduced conflicts and merge errors.&lt;/li>
&lt;/ul>
&lt;h2 id="disadvantages-1">Disadvantages
&lt;/h2>&lt;ul>
&lt;li>Lacks the structure of Gitflow.&lt;/li>
&lt;li>Unsuitable for large projects or those requiring support for multiple versions.&lt;/li>
&lt;li>Does not define clear processes for releases or bug fixes.&lt;/li>
&lt;/ul>
&lt;h1 id="gitlab-flow">GitLab Flow
&lt;/h1>&lt;p>&lt;a class="link" href="https://about.gitlab.com/topics/version-control/what-is-gitlab-flow" target="_blank" rel="noopener"
>&lt;strong>GitLab Flow&lt;/strong>&lt;/a> combines elements of Gitflow and GitHub Flow. It introduces &lt;strong>environment branches&lt;/strong> like &lt;strong>staging&lt;/strong> and &lt;strong>production&lt;/strong>, making it suitable for &lt;strong>CI/CD&lt;/strong> and tightly integrated with GitLab’s &lt;strong>CI/CD&lt;/strong> tools.&lt;/p>
&lt;p>&lt;img src="https://namanh11611.github.io/p/git-branching-strategy/gitlab_flow.png"
width="3840"
height="3321"
srcset="https://namanh11611.github.io/p/git-branching-strategy/gitlab_flow_hu10733650273199178720.png 480w, https://namanh11611.github.io/p/git-branching-strategy/gitlab_flow_hu15393612771178078040.png 1024w"
loading="lazy"
alt="GitLab Flow"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
>&lt;/p>
&lt;p>Similar to GitHub Flow, GitLab Flow works directly with the primary branch, &lt;strong>main&lt;/strong>, which contains stable source code ready for release. This flow also includes feature branches for developing new features.&lt;/p>
&lt;p>When the code on the &lt;strong>main&lt;/strong> branch is ready for testing, we &lt;code>merge&lt;/code> it into the &lt;strong>staging&lt;/strong> branch. After testing and confirming it is ready for deployment, we &lt;code>merge&lt;/code> the code from the &lt;strong>staging&lt;/strong> branch into the &lt;strong>production&lt;/strong> branch. GitLab Flow often uses &lt;strong>release&lt;/strong> branches, such as &lt;strong>release/v1&lt;/strong> and &lt;strong>release/v2&lt;/strong>, to independently manage and deploy different versions of the application.&lt;/p>
&lt;p>However, when there is a bug in production, you need to merge the code into the &lt;strong>main&lt;/strong> branch first, then &lt;code>merge&lt;/code> or &lt;code>cherry-pick&lt;/code> it into other branches following the above process.&lt;/p>
&lt;h2 id="advantages-2">Advantages
&lt;/h2>&lt;ul>
&lt;li>Simpler than Gitflow, but more structured than GitHub Flow.&lt;/li>
&lt;li>Well-suited for &lt;strong>CI/CD&lt;/strong> projects with multiple environments.&lt;/li>
&lt;li>Supports independent management of different application versions using &lt;strong>release&lt;/strong> branches.&lt;/li>
&lt;/ul>
&lt;h2 id="disadvantages-2">Disadvantages
&lt;/h2>&lt;ul>
&lt;li>Best suited for GitLab and its &lt;strong>CI/CD&lt;/strong> tools.&lt;/li>
&lt;li>Requires careful setup to leverage its full potential.&lt;/li>
&lt;li>Not ideal for projects without &lt;strong>CI/CD&lt;/strong> requirements.&lt;/li>
&lt;/ul>
&lt;h1 id="trunk-based-development">Trunk-Based Development
&lt;/h1>&lt;p>For a detailed discussion, refer to my article: &lt;a class="link" href="../trunk-based-development" >Trunk-Based Development - A Git Workflow to Reduce Merge Conflicts&lt;/a>. &lt;strong>Trunk-Based Development (TBD)&lt;/strong> is a strategy where all developers work on a single main branch, typically &lt;strong>main&lt;/strong>. Changes are continuously and quickly committed to this branch, minimizing the lifespan of feature branches.&lt;/p>
&lt;h2 id="advantages-3">Advantages
&lt;/h2>&lt;ul>
&lt;li>Encourages &lt;strong>CI&lt;/strong> and minimizes merge conflicts.&lt;/li>
&lt;li>Ideal for Agile and DevOps projects requiring &lt;strong>CD&lt;/strong>.&lt;/li>
&lt;li>Easy to manage and track the codebase.&lt;/li>
&lt;/ul>
&lt;h2 id="disadvantages-3">Disadvantages
&lt;/h2>&lt;ul>
&lt;li>Higher risk of directly committing errors to the main branch.&lt;/li>
&lt;li>Requires robust code reviews and automation tests to maintain stability.&lt;/li>
&lt;li>Unsuitable for large, distributed teams.&lt;/li>
&lt;/ul>
&lt;h1 id="choosing-the-right-strategy">Choosing the Right Strategy
&lt;/h1>&lt;p>There’s no one-size-fits-all solution. The choice of Git branching strategy depends on factors like project scale, team structure, and development requirements. Below are some suggestions:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Project Type&lt;/th>
&lt;th>Team Size&lt;/th>
&lt;th>Recommended Strategy&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Small to medium projects with continuous delivery&lt;/td>
&lt;td>Small, Medium&lt;/td>
&lt;td>GitHub Flow, TBD&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Scheduled and periodic releases&lt;/td>
&lt;td>Medium&lt;/td>
&lt;td>GitFlow, GitLab Flow&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CI/CD projects with multiple environments&lt;/td>
&lt;td>Medium, Large&lt;/td>
&lt;td>GitLab Flow&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Long-term maintenance projects&lt;/td>
&lt;td>Large&lt;/td>
&lt;td>GitFlow&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Each strategy has its pros and cons. The key is selecting one that aligns with your team’s workflow and project requirements. Doing so optimizes productivity and minimizes risks in source code management.&lt;/p>
&lt;h1 id="referrence">Referrence
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://nvie.com/posts/a-successful-git-branching-model" target="_blank" rel="noopener"
>https://nvie.com/posts/a-successful-git-branching-model&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.github.com/en/get-started/using-github/github-flow" target="_blank" rel="noopener"
>https://docs.github.com/en/get-started/using-github/github-flow&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://about.gitlab.com/topics/version-control/what-is-gitlab-flow" target="_blank" rel="noopener"
>https://about.gitlab.com/topics/version-control/what-is-gitlab-flow&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy" target="_blank" rel="noopener"
>https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.geeksforgeeks.org/branching-strategies-in-git" target="_blank" rel="noopener"
>https://www.geeksforgeeks.org/branching-strategies-in-git&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.abtasty.com/blog/git-branching-strategies" target="_blank" rel="noopener"
>https://www.abtasty.com/blog/git-branching-strategies&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Trunk Based Development - một Git workflow giúp giảm cơn đau đầu resolve conflict</title><link>https://namanh11611.github.io/p/trunk-based-development/</link><pubDate>Wed, 03 May 2023 02:07:00 +0700</pubDate><guid>https://namanh11611.github.io/p/trunk-based-development/</guid><description>&lt;img src="https://namanh11611.github.io/p/trunk-based-development/tbd.jpeg" alt="Featured image of post Trunk Based Development - một Git workflow giúp giảm cơn đau đầu resolve conflict" />&lt;h1 id="case-study">Case study
&lt;/h1>&lt;h2 id="câu-chuyện-đầu-tiên">Câu chuyện đầu tiên
&lt;/h2>&lt;p>Ở công ty cũ của mình (tạm gọi là công ty A), source code của dự án siêu to khổng lồ, mới clone về đã 40GB, compile và build các kiểu thì còn lên đến gần 100GB. Mỗi lần anh em code một feature nào đó, thường sẽ checkout ra một branch mới là feature_x. Feature nhỏ thì không sao, chứ feature lớn mà thay đổi vài chục hay đến cả trăm file, xong merge vào branch chính thì đúng là ác mộng, vì phải resolve conflict từ code của branch feature_a, feature_b nào đó merge trước đó.&lt;/p>
&lt;h2 id="câu-chuyện-thứ-hai">Câu chuyện thứ hai
&lt;/h2>&lt;p>Ở công ty khác của mình (công ty B), do đặc thù của dự án mà project được chia thành 5 team nhỏ, mỗi team tầm 3 developer. Mỗi team nhỏ sẽ phụ trách một vài feature trong 1 sprint. Khi bắt đầu sprint, dev lead tạo branch cho từng team, và sẽ merge 5 branch đó sau khi kết thúc sprint. Vấn đề phát sinh tương tự là merge code xảy ra khá nhiều conflict, và các team lại mất thời gian test lại feature của mình để đảm bảo không xảy ra bug sau khi merge.&lt;/p>
&lt;h1 id="vậy-trunk-based-development-là-gì">Vậy Trunk Based Development là gì?
&lt;/h1>&lt;p>Nói một cách ngắn gọn, &lt;strong>Trunk Based Development&lt;/strong> (từ sau mình sẽ viết tắt &lt;strong>TBD&lt;/strong>) là một &lt;strong>source-control branching model&lt;/strong> (mô hình làm việc với các nhánh) mà tất cả developers sẽ làm việc trên &lt;strong>một branch duy nhất&lt;/strong>, gọi là &lt;strong>trunk&lt;/strong> (nghĩa là cái thân cây), tránh việc tạo ra các feature branch siêu to khổng lồ. &lt;strong>Trunk&lt;/strong> branch cần đảm bảo rằng nó có thể sẵn sàng release bất cứ thời điểm nào. Trong các dự án, mọi người thường sẽ đặt tên cho trunk branch là &lt;strong>master&lt;/strong> hoặc &lt;strong>dev&lt;/strong>.&lt;/p>
&lt;p>TBD lại chia thành 2 mô hình nhỏ hơn, phù hợp với từng team. Chúng ta sẽ cùng đi tìm hiểu ngay sau đây.&lt;/p>
&lt;h2 id="tbd-cho-team-nhỏ">TBD cho team nhỏ
&lt;/h2>&lt;p>&lt;img src="https://images.viblo.asia/3c277b1e-cfc8-4b33-964f-240189208025.png"
loading="lazy"
alt="Small TBD"
>
Trong mô hình này, toàn bộ dev team sẽ push code trực tiếp lên trunk branch. Tuy nhiên, mô hình này mình thấy có rủi ro rất lớn về chất lượng code, vì code được push trực tiếp mà không qua review. Vậy nên, để áp dụng mô hình này, các dev tham gia project cũng phải có technical skill rất tốt, để đảm bảo rằng từng dòng code mình push lên không gây bug cho tất cả anh em.&lt;/p>
&lt;p>Cá nhân mình đánh giá mô hình này có lẽ chỉ phù hợp với team size từ 5 người trở xuống.&lt;/p>
&lt;h2 id="tbd-cho-team-to">TBD cho team to
&lt;/h2>&lt;p>&lt;img src="https://images.viblo.asia/8cfdf280-8b7a-4751-b50e-4706b9753669.png"
loading="lazy"
alt="Scaled TBD"
>&lt;/p>
&lt;p>Với TBD cho một team lớn, các feature branch vẫn được tạo, nhưng điểm khác biệt là nó chỉ được tạo trong một thời gian ngắn, chỉ vài commit là merge lại trunk branch ngay.&lt;/p>
&lt;p>Ví dụ khi được giao task code Onboarding feature, với Git flow mà thông thường mọi người đang áp dụng, các bạn sẽ làm những bước như sau:&lt;/p>
&lt;ol>
&lt;li>Tạo &lt;strong>feature/onboarding&lt;/strong> branch&lt;/li>
&lt;li>Code Welcome screen rồi commit&lt;/li>
&lt;li>Code Register screen rồi commit tiếp&lt;/li>
&lt;li>Code Login screen rồi commit nữa&lt;/li>
&lt;li>Code xong hết rồi thì tạo merge request, chờ dev khác review code&lt;/li>
&lt;li>Review xong thì merge &lt;strong>feature/onboarding&lt;/strong> branch vào &lt;strong>dev&lt;/strong> branch&lt;/li>
&lt;/ol>
&lt;p>Với quy trình như trên, merge request có thể chứa vài chục file thay đổi, và review đống code ấy thực sự là ác mộng. Đôi khi, vào thời điểm chúng ta tạo merge request, còn xảy ra conflict với code của một feature nào đó đã merge vào &lt;strong>dev&lt;/strong> branch trước. Và chúng ta lại phải hì hục ngồi resolve conflict.&lt;/p>
&lt;p>&lt;img src="https://images.viblo.asia/766696b2-7172-42b3-b0d8-2e1af375f59d.png"
loading="lazy"
>&lt;/p>
&lt;p>Đối với reviewer, đôi khi cách để thoát khỏi ác mộng là không mơ nữa, nghĩa là bác senior dev sẽ nhanh chóng để lại dòng comment ngắn gọn &lt;strong>LGTM&lt;/strong> (Look good to me), vậy là anh chàng junior dev dễ dàng merge code vào &lt;strong>dev&lt;/strong> branch. Hoặc mặc dù bác senior dev đã cố gắng review cẩn thận, nhưng với lượng code thay đổi lớn như vậy thì vẫn bị lọt một vài bug. Tựu chung lại thì quy trình này vẫn có rủi ro trong việc để lọt bug.&lt;/p>
&lt;p>Đối với TBD, quy trình sẽ điều chỉnh lại một chút như sau:&lt;/p>
&lt;ol>
&lt;li>Tạo &lt;strong>feature/welcome_screen&lt;/strong> branch&lt;/li>
&lt;li>Code Welcome screen rồi commit, tạo merge request luôn&lt;/li>
&lt;li>Trong lúc chờ review thì code Register screen tiếp&lt;/li>
&lt;li>Khi Merge request của Welcome screen được approve, lại checkout ra &lt;strong>feature/register_screen&lt;/strong> branch để tạo merge request mới&lt;/li>
&lt;li>Tương tự như vậy với Login screen&lt;/li>
&lt;/ol>
&lt;p>Giờ đây, mỗi merge request của chúng ta chỉ chứa vài file thay đổi, bác senior dev có thể review code dễ dàng hơn.&lt;/p>
&lt;p>Và kể cả khi branch release có bug, chúng ta cần hotfix thì dev cũng không merge trực tiếp vào release branch như các mô hình khác, mà tất cả đều phải merge vào trunk branch.&lt;/p>
&lt;h2 id="feature-flag">Feature flag
&lt;/h2>&lt;p>Các bạn có thể thắc mắc rằng làm như vậy thì trên &lt;strong>dev&lt;/strong> branch sẽ chứa đầy code dở dang của các feature. Ví dụ app sẽ hiển thị Welcome screen với UI mới, trong khi Register và Login screen thì vẫn là UI cũ. Như vậy, làm sao có thể đảm bảo rằng trunk branch có thể release bất cứ lúc nào?&lt;/p>
&lt;p>Chìa khoá để giải quyết vấn đề này chính là &lt;strong>Feature flag&lt;/strong>. Với mỗi feature dang dở như vậy, bạn cần đặt cho nó một cái flag, để khi bật flag, tất cả code của feature mới sẽ hoạt động, còn nếu tắt flag, app sẽ hoạt động như code hiện tại. Ví dụ:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ONBOARDING_FLAG&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FLAG_ON&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">displayNewWelcomeScreen&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">displayOldWelcomeScreen&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ONBOARDING_FLAG&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FLAG_ON&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">displayNewRegisterScreen&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">displayOldRegisterScreen&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ONBOARDING_FLAG&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FLAG_ON&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">displayNewLoginScreen&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">displayOldLoginScreen&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Đôi khi, bạn muốn revert một feature thì cũng chỉ cần tắt flag của nó đi là xong. Quá nhanh chóng phải không nào?&lt;/p>
&lt;h1 id="ưu-điểm">Ưu điểm
&lt;/h1>&lt;h2 id="giảm-conflict-giảm-thời-gian-review-code">Giảm conflict, giảm thời gian review code
&lt;/h2>&lt;p>Như mình đã trình bày ở trên, TBD yêu cầu mọi người phải nhanh chóng merge code của mình vào trunk branch, điều này giúp giảm conflict code, đồng thời giảm thời gian review code.&lt;/p>
&lt;p>Với case study thứ 2 của công ty B, sau một thời gian thấy mô hình hiện tại không hiệu quả, mình đã đề xuất với dev lead áp dụng TBD. Và đúng như mong đợi, với mỗi sprint, hầu như team mình không còn phải dành quá nhiều thời gian resolve conflict nữa.&lt;/p>
&lt;h2 id="cicd">CI/CD
&lt;/h2>&lt;p>TBD thực sự rất hữu ích cho CI/CD. Nghĩ mà xem, giờ đây bạn chỉ cần setup và run CI/CD trên một branch duy nhất. Tất cả những commit của mọi người sẽ nhanh chóng được check coding convention, unit test cẩn thận, giúp cả team dễ dàng phát hiện ra lỗi sai và fix nó kịp thời.&lt;/p>
&lt;h2 id="ab-testing">A/B Testing
&lt;/h2>&lt;p>Với feature flag, bạn cũng dễ dàng bật tắt các feature, giúp Product Manager thuận tiện setup các A/B Testing. Từ đó có thể đo lường để đưa ra đánh giá chính xác về hiệu quả của một feature mới.&lt;/p>
&lt;p>Ở case study thứ nhất của công ty A, thực sự thì chúng mình đã apply feature flag cho rất nhiều feature quan trọng để thực hiện A/B testing.&lt;/p>
&lt;h2 id="nhanh-chóng-deliver-sản-phẩm">Nhanh chóng deliver sản phẩm
&lt;/h2>&lt;p>Vì code ở trunk branch luôn sẵn sàng release nên mình thấy nó khá phù hợp với các start-up. Bất cứ khi nào bạn muốn release một version mới, chỉ cần checkout từ trunk branch, bật các feature flag đã hoàn thành và tắt các feature flag còn dang dở, rồi build code.&lt;/p>
&lt;h1 id="nhược-điểm">Nhược điểm
&lt;/h1>&lt;h2 id="quá-nhiều-code-dư-thừa">Quá nhiều code dư thừa
&lt;/h2>&lt;p>Nói đi cũng phải nói lại, việc áp dụng &lt;strong>feature flag&lt;/strong> và if else quá nhiều có thể khiến code của bạn trở nên phức tạp. Đôi khi có một số function, code if else không clear có thể khiến reviewer còn cảm thấy khó hiểu hơn.&lt;/p>
&lt;p>Và khi một feature được release, bạn cũng lại phải quay lại để xoá code flow cũ đi, như các function &lt;code>displayOldWelcomeScreen&lt;/code>, &lt;code>displayOldRegisterScreen&lt;/code> và &lt;code>displayOldLoginScreen&lt;/code> trong ví dụ trên.&lt;/p>
&lt;h2 id="không-phù-hợp-với-team-có-nhiều-junior">Không phù hợp với team có nhiều junior
&lt;/h2>&lt;p>Việc tạo merge request liên tục yêu cầu các dev phải cẩn trọng, đảm bảo rằng mỗi commit của mình đã pass tất cả coding convention check hay unit test ở local, và đặc biệt là không có critical bug. Vì nếu có bug trên trunk branch khiến cho không thể mở được app chẳng hạn, nó sẽ block công việc của tất cả các dev khác.&lt;/p>
&lt;p>Nếu dùng feature flag, dev còn cần test cả 2 flow cũ và mới để đảm bảo cả 2 đều hoạt động đúng.&lt;/p>
&lt;p>Vậy nên mình nghĩ rằng một team gồm chủ yếu là senior sẽ phù hợp hơn với mô hình này.&lt;/p>
&lt;h1 id="lời-kết">Lời kết
&lt;/h1>&lt;p>TBD là một mô hình làm việc mà mình đã áp dụng ở một số công ty và thấy nó hoạt động khá hiệu quả với tình hình của team mình lúc đó. Các bạn có thể nghiên cứu ưu, nhược điểm của mô hình so với team mình và áp dụng thử nhé.&lt;/p>
&lt;h1 id="reference">Reference
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener"
>https://trunkbaseddevelopment.com/&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Quy trình làm việc chuẩn chỉ với Git</title><link>https://namanh11611.github.io/p/git-process/</link><pubDate>Tue, 10 Nov 2020 17:19:00 +0700</pubDate><guid>https://namanh11611.github.io/p/git-process/</guid><description>&lt;img src="https://namanh11611.github.io/p/git-process/git.jpeg" alt="Featured image of post Quy trình làm việc chuẩn chỉ với Git" />&lt;h1 id="lời-mở-đầu">Lời mở đầu
&lt;/h1>&lt;p>Trải qua một thời gian đi làm, lang bạt qua vài công ty, mình nhận thấy ở mỗi nơi lại có quy trình làm việc với Git khác nhau. Bài viết này giới thiệu quy trình làm việc với Git mà mình nghĩ là chuẩn chỉ và cũng đang áp dụng ở công ty hiện tại. Vậy nên, mình sẽ không giới thiệu hết các lệnh Git, mà chỉ lướt qua những lệnh mình nghĩ đủ dùng cho quá trình làm việc của các bạn ở công ty.&lt;/p>
&lt;h1 id="quy-trình">Quy trình
&lt;/h1>&lt;h2 id="ngày-đầu-tiên-đi-làm">Ngày đầu tiên đi làm
&lt;/h2>&lt;p>Đơn giản quá nhỉ, ngày đầu tiên đi làm thì còn lệnh gì ngoài &lt;code>git clone&lt;/code> nữa cơ chứ. Khi bạn muốn lấy source của team về, thì chỉ cần mở terminal, gõ:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git clone &amp;lt;url&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Thêm 1 típ nhỏ, là nếu bạn muốn tên folder sau khi clone về khác tên project trên remote thì hãy đặt tên folder ở cuối lệnh:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git clone &amp;lt;url&amp;gt; folder_name
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="những-ngày-bình-thường">Những ngày bình thường
&lt;/h2>&lt;h3 id="một-mình-một-ngựa">Một mình một ngựa
&lt;/h3>&lt;p>Sếp giao một feature mới, bắt tay vào làm thôi nào. Khoan đã, nếu bạn đang ở 1 branch khác, đừng quên checkout về branch chính của team (thường branch chính sẽ đặt tên là master):&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git checkout master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Rồi pull code mới nhất về:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git pull
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Để kiểm tra code ở local đã update chưa, bạn hãy thử kiểm tra bằng &lt;code>git log&lt;/code>. Mình thì thường dùng lệnh này để xem cho gọn:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git log --oneline
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Sau đó, checkout ra một branch mới để bắt đầu làm feature của bạn. Thêm param &lt;code>-b&lt;/code> sẽ giúp bạn tạo branch mới và checkout sang đó luôn:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git checkout -b feature_branch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;p>Code&amp;hellip; code&amp;hellip; code&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>Xong rồi, bây giờ thì bắt đầu add những file bạn đã sửa vào stage. Thường thì các IDE hiện tại đều support bạn add và commit nhanh hơn, nhưng nếu bạn vẫn muốn gõ tay thì hãy gõ:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git add .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Lệnh vừa rồi đã giúp bạn add tất cả những file vừa sửa vào stage. Sau đó thì commit:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s2">&amp;#34;Fix all bugs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>Note:&lt;/strong> Cách đặt tên branch và commit cũng nên rõ ràng, thể hiện branch đó, commit đó thực hiện feature gì hay là fix bug gì. Điều này hoàn toàn phụ thuộc vào rules của từng team. Có những team đặt tiền tố là ID của task, nhưng có team lại đặt tiền tố là mục đích của commit đó là gì, ví dụ như feature/fixbug/&amp;hellip;&lt;/p>
&lt;p>Và cuối cùng là push code lên repository:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git push origin feature_branch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Bây giờ thì lên repository, tạo merge request cho sếp review. Trong lúc đó thì tranh thủ đi làm cốc coffee để chờ bước tiếp theo.&lt;/p>
&lt;h3 id="feature-nhiều-người-làm">Feature nhiều người làm
&lt;/h3>&lt;p>Nếu branch của bạn có nhiều người làm chung, bạn chưa kịp push code thì đã có người khác push trước. Vậy thì trước khi push thì hãy pull theo cách này:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git pull --rebase
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Commit của bạn sẽ được đẩy lên trên commit của đồng nghiệp trong log.&lt;/p>
&lt;p>Trong trường hợp bạn muốn lấy code về nhưng chưa muốn merge thì hãy dùng lệnh:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git fetch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Theo mình thì &lt;code>pull = fetch + merge&lt;/code>.&lt;/p>
&lt;h3 id="merge-code">Merge code
&lt;/h3>&lt;p>Sau một hồi review thì sếp cũng đồng ý cho bạn merge code, nhưng vấn đề là trong quá trình review thì bạn có thêm một vài commit để thêm, sửa, xóa file. Bạn muốn rebase những commit đó lại thành 1, hoặc đơn giản chỉ muốn sửa tên hay xóa commit nào đó. Giả sử bạn có 3 commit cần hợp nhất:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git rebase -i HEAD~3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Terminal hiện ra cho bạn khá nhiều option như edit, reword, squash&amp;hellip; Thay chữ pick ở đầu dòng bằng option tương ứng mà bạn muốn dùng. Sau đó bấm Ctrl + O để ghi đè, tiếp tục Ctrl + X để thoát.&lt;/p>
&lt;p>Còn một vấn đề nữa là branch master đã có người khác push thêm code. Bạn vẫn có thể merge, nhưng nó sẽ tạo thêm 1 commit merge. Vậy nên mình thường sẽ rebase và merge fast forward.
Đầu tiên, vẫn là:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git fetch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Sau đó là lệnh rebase. Bạn vẫn phải đứng ở &lt;code>feature_branch&lt;/code> để thực hiện lệnh này:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git rebase origin/master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Nói một cách dễ hiểu, lệnh rebase sẽ giúp bạn lấy những code mới nhất từ branch master về, sau đó &lt;em>&amp;ldquo;viết lại&amp;rdquo;&lt;/em> branch feature của bạn để đẩy commit của bạn lên trên cùng.
Cuối cùng là push force lên feature branch. Push force sẽ apply toàn bộ log ở local của bạn lên branch ở repo, bất chấp log 2 nơi khác nhau:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git push -f origin feature_branch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Nếu branch một mình bạn làm thì có thể push force thoải mái. Nhưng &lt;strong>hãy cân nhắc cẩn thận khi push force lên branch có nhiều người làm chung&lt;/strong>, vì nó sẽ dễ gây conflict cho người khác. Chỉ làm điều này khi bạn đã chắc chắn hoàn thành feature của mình.&lt;/p>
&lt;p>Sau đó, merge code ở merge request trên repo. Vậy là bạn đã hoàn thành xuất sắc task đầu tiên rồi.&lt;/p>
&lt;h2 id="những-ngày-khủng-hoảng">Những ngày khủng hoảng
&lt;/h2>&lt;h3 id="reset">Reset
&lt;/h3>&lt;p>Thực ra thì trong quá trình làm có thể bạn có nhầm lẫn gì đó mà cần revert code. Git reset sẽ có 3 option dành cho bạn.&lt;/p>
&lt;p>Reset commit nhưng code vẫn ở trong stage, sẵn sàng cho bạn commit lại:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git reset --soft commit_id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Reset commit và đẩy code ra khỏi stage. Bạn cần dùng &lt;code>git add&lt;/code> trước khi có thể commit lại:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git reset --mixed commit_id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Reset commit và xóa toàn bộ code bạn đã làm:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git reset --hard commit_id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="stash">Stash
&lt;/h3>&lt;p>Bạn có thể dùng cái này như một cứu cánh để lưu tạm code trước khi thực hiện các lệnh rebase hay checkout sang branch khác mà bị conflict. Bạn cứ tưởng tượng nó như một tờ giấy nháp lưu theo cấu trúc stack vậy.&lt;/p>
&lt;p>Khi muốn lưu tất cả những thay đổi hiện tại vào stash:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git stash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Khi muốn apply stash cuối cùng vừa lưu:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git stash pop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Hiện tại mình đang dùng chủ yếu Android Studio, và nó có sẵn Shelf với chức năng tương tự nên hiện tại không còn dùng đến git stash.&lt;/p>
&lt;p>Bạn có thể tham khảo thêm ở &lt;a class="link" href="https://git-scm.com/docs/git-stash" target="_blank" rel="noopener"
>đây&lt;/a>.&lt;/p>
&lt;h1 id="kết">Kết
&lt;/h1>&lt;p>Thực ra cái tiêu đề chỉ giật tít câu view thôi chứ không có gì là chuẩn chỉ cả. Vì quy trình của mỗi công ty là khác nhau, yêu cầu của dự án là khác nhau. Nếu dự án bạn ít người, cần ưu tiên tốc độ làm việc thì có thể bỏ bớt quy trình, push thẳng code lên master. Còn nếu dự án của bạn có nhiều người cùng làm, yêu cầu quy trình khắt khe thì có thể không cho push force lên remote chẳng hạn. Vậy quy trình của công ty của bạn thế nào? Cùng chia sẻ với mình nhé.&lt;/p>
&lt;p>Thanks for reading!&lt;/p></description></item></channel></rss>