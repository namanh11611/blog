[{"content":"Photo by AltumCode on Unsplash\nWill AI Replace Developers Soon? Many people have asked me whether AI is about to replace developers. My answer, as of now, is NO. There still needs to be someone to verify the code that AI produces.\nHowever, the tech industry evolves rapidly. Technologies that are hot today might become obsolete tomorrow. For example, six years ago when I graduated, coding for Android was primarily done using Java. But now, if you only know Java without Kotlin, it’s incredibly difficult to find a job.\nSo, will AI replace developers in the next 5 years or 10 years? I can’t say for certain.\nAI is Changing the Way We Work That said, it’s clear that AI is transforming how we work.\nIn the past, a developer’s primary job was to convert requirements and designs into code. Tech leads and seniors would spend additional time in meetings to clarify requirements, but junior developers spent most of their time coding. It could take months or even years to deliver a product.\nRecently, I’ve been working on a new personal project. Today marks day 10, but with the help of Cursor, the code I’ve written or directly modified accounts for just 5%.\nIn the past, using ChatGPT, you could only generate small components and then copy them into your project. Even then, you’d need to spend a lot of time fixing them to fit. But with Cursor, it’s different. It understands the project context. By providing it with a base project and some pre-written files, it can replicate 99% of the format, and the code is almost ready to use with little or no modifications.\nCursor acts as an AI Agent: after generating code, it even creates new files, runs the project to check for errors, and fixes them automatically before asking me to review the changes.\nMy role now resembles that of a technical lead: I define tasks for Cursor, review its output, and ask it to fix anything suboptimal. Once I’m satisfied, I merge the code.\nBut to review AI-generated code, you must understand what each line means and identify what isn’t optimized so you can instruct it to make corrections. Blindly applying AI-generated solutions can be risky. If bugs arise later, you may not know how to fix them.\nThe Reality Currently, a barrier to adoption in large companies is their hesitation to use AI due to data security concerns. Additionally, their codebases are vast, and using general AI tools to train on them can be token-intensive. AI has limitations in the number of tokens it can retain.\nFor me, AI isn’t much help in my company projects. However, for small companies or indie hackers, these barriers are less significant, creating opportunities to accelerate software development. Imagine cutting down the time to build an MVP from months to just weeks, or even days.\nThe numbers don’t lie—traffic to StackOverflow is declining. Developers are now asking AI for help more often than they use Google.\nReturning to the question at the start: if a team once required 3 seniors and 7 juniors, but after adopting AI, productivity improves and the team now only needs 3 seniors and 4 juniors, hasn’t AI effectively replaced 3 juniors? More accurately, those who effectively leverage AI are taking over the roles of those who don’t.\nConclusion As the new year begins, I’m reflecting on my work so that future me can look back on this. During the First Industrial Revolution, machines replaced humans in tedious manual labor, freeing us to focus our intellect on other tasks. Let’s see where AI will take us in the next 5 years or 10 years.\n","date":"2025-01-01T00:00:00+07:00","image":"https://namanh11611.github.io/p/ai-change-work/ai_change_work_hu7372324161217069165.jpg","permalink":"https://namanh11611.github.io/p/ai-change-work/","title":"AI is Changing How Software Engineers Work"},{"content":"Photo by Dillon Shook on Unsplash\nHave you ever struggled to choose one of the seven types of providers in Riverpod for specific use cases in your project? For instance, the documentation explains that both NotifierProvider and StateNotifierProvider are used when:\nA complex state object that is immutable except through an interface.\nOn the other hand, ChangeNotifierProvider are not recommended for scalable applications.\nWhat is going on??? The author really knows how to make developers feel confused…\nBut now, Remi Rousselet has introduced a new way to use Riverpod with code generation, making developers\u0026rsquo; lives a bit easier.\nSyntax In simple terms, code generation in Riverpod allows us to declare providers using the @riverpod annotation, and most of the code is automatically generated using Dart\u0026rsquo;s built-in build_runner tool.\nInstead of defining providers as before:\n1 2 3 4 final fetchUserProvider = FutureProvider.autoDispose.family\u0026lt;User, int\u0026gt;((ref, userId) async { final json = await http.get(\u0026#39;api/user/$userId\u0026#39;); return User.fromJson(json); }); Now, you only need to write:\n1 2 3 4 5 @riverpod Future\u0026lt;User\u0026gt; fetchUser(FetchUserRef ref, {required int userId}) async { final json = await http.get(\u0026#39;api/user/$userId\u0026#39;); return User.fromJson(json); } Instead of deliberating over which of the seven providers to use, you can now use the following table to quickly choose the appropriate provider for your use case:\nFunctional (Can’t perform side-effects using public methods) Class-Based (Can perform side-effects using public methods) Sync Async - Future Async - Stream keepAlive In this new approach, all providers are auto-dispose by default, meaning their state is destroyed when no listeners observe them. This is the opposite of the old approach (where you had to explicitly add autoDispose, and the default was no dispose).\nTo disable auto-dispose and keep your provider alive, use:\n1 @Riverpod(keepAlive: true) Parameters As seen in the earlier example, adding parameters to a provider is now as straightforward as adding parameters to a regular function. There’s no need to use family like in the old approach.\nFor functional providers, parameters are added directly to the function:\n1 2 3 4 5 6 7 8 @riverpod String example( ExampleRef ref, int param1, { String param2 = \u0026#39;foo\u0026#39;, }) { return \u0026#39;Hello $param1 \u0026amp; param2\u0026#39;; } For class-based providers, parameters are added to the build method:\n1 2 3 4 5 6 7 8 9 10 11 12 @riverpod class Example extends _$Example { @override String build( int param1, { String param2 = \u0026#39;foo\u0026#39;, }) { return \u0026#39;Hello $param1 \u0026amp; param2\u0026#39;; } // Add methods to mutate the state } Advantages Currently, using code generation or the old approach is optional. If you’re considering why you should switch, here are some reasons provided by the author:\nBetter syntax, more readable/flexible, and with a reduced learning curve. No need to worry about the type of provider. Write your logic, and Riverpod will pick the most suitable provider for you. The syntax no longer looks like we\u0026rsquo;re defining a \u0026ldquo;dirty global variable\u0026rdquo;. Instead we are defining a custom function/class. Passing parameters to providers is now unrestricted. Instead of being limited to using .family and passing a single positional parameter, you can now pass any parameter. This includes named parameters, optional ones, and even default values. Stateful hot-reload of the code written in Riverpod. Better debugging, through the generation of extra metadata that the debugger then picks up. Some Riverpod features will be available only with code generation. Disadvantages However, when applied to real-world projects, there are some drawbacks to consider.\nCurrently, as code generation is relatively new, few projects have adopted it, making it hard to find reference source code. For the most part, you’ll rely on Riverpod’s documentation during development.\nIn this AI-driven era, developers often use tools to generate code. With limited adoption, most tools generate Riverpod code in the old style. But don’t worry! Android Studio has the Flutter Riverpod Snippets plugin, which helps you write code faster. Just type riverpod, and it will suggest the four main provider types.\nThese drawbacks are temporary. As code generation becomes more popular, these issues will be resolved. So there’s no need to worry too much.\nReference https://riverpod.dev/docs/concepts/about_code_generation ","date":"2024-10-11T00:00:00+07:00","image":"https://namanh11611.github.io/p/riverpod/riverpod_hu9129665672805090424.jpg","permalink":"https://namanh11611.github.io/p/riverpod/","title":"Using Code Generation Providers in Flutter Riverpod to Simplify Life"},{"content":"Photo by Etienne Girardet on Unsplash\nIn Android, performing heavy tasks like network requests or database operations on the main thread can cause the app to freeze or crash. To ensure smoother app performance, these tasks should be executed on a background thread to avoid blocking the main thread. For instance, when a user clicks the Submit button on the main thread, the network request will be processed on a background thread, and the result will be sent back to the main thread. Android provides tools such as Looper, MessageQueue, and Handler to manage concurrent tasks and handle message passing between threads.\nWait a second! Isn’t Kotlin Coroutines already solving these problems? That’s true; nowadays, Kotlin Coroutines are widely used for such use cases. However, in certain projects, for example Android Automotive, the trio of Looper, MessageQueue, and Handler is still essential.\nIn this article, I’ll explain the role and responsibilities of each component and how they interact with one another. Since these components are closely intertwined, you might need to refer back to earlier sections to fully grasp the concepts. Take your time!\nLooper Looper is a class that manages the message loop for a thread, with each thread having exactly one Looper. If we dive into the Android SDK code, we can see the Looper class defined as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public final class Looper { // Looper contains the MessageQueue final MessageQueue mQueue; // The relationship between Looper and Thread is one-to-one final Thread mThread; public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { // Each thread can have only one Looper if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); } private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } } By default, threads are not associated with any message loop. To create a message loop, we need to call the Looper.prepare() method, as shown above. Then, we invoke the Looper.loop() method to process messages until the loop stops.\nHere’s an example of a Looper implementation:\n1 2 3 4 5 6 class LooperExampleThread extends Thread { public void run() { Looper.prepare(); Looper.loop(); } } MessageQueue MessageQueue is a data structure that holds a list of Message and Runnable objects to be processed. It operates on a FIFO (First-In-First-Out) basis. You can access the MessageQueue of the current thread using the Looper.myQueue() method.\nIn the Looper code above, you’ll notice that each Looper has exactly one MessageQueue:\n1 2 3 4 public final class Looper { // Looper contains the MessageQueue final MessageQueue mQueue; } Messages are not added directly to the MessageQueue. Instead, they are added through a Handler. The Looper continuously extracts and processes messages from the queue.\nHandler Handler is a class used to send and process Message and Runnable objects linked to a thread’s MessageQueue. Each Handler is associated with a specific thread and its MessageQueue.\nWhen creating a Handler, you must pass a Looper to its constructor. Here’s an example of a typical constructor:\n1 public Handler(@NonNull Looper looper) {} The MessageQueue we mentioned earlier belongs to the Looper passed here, and messages will be executed on the same thread as that Looper.\nSome commonly used methods of Handler include:\npost(Runnable) postAtTime(java.lang.Runnable, long) postDelayed(Runnable, Object, long) sendEmptyMessage(int) sendMessage(Message) sendMessageAtTime(Message, long) sendMessageDelayed(Message, long) Handler serves two main purposes:\nScheduling tasks to run in the future. You can use methods like ...AtTime or ...Delayed. Executing tasks on a different thread from the current one. As mentioned earlier, you can specify the desired thread by passing its Looper when initializing the Handler. Communication Between Components When a Message or Runnable is sent via a Handler, it is added to the MessageQueue. The Looper continuously checks the MessageQueue for new messages. Upon finding a message, the Looper extracts it from the queue and forwards it to the corresponding Handler for processing. The Handler processes the message on the thread it is associated with. Here’s an illustrative code example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class ProcessingThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); // Looper.myLooper() return the Looper object // associated with the current thread mHandler = new Handler(Looper.myLooper()) { public void handleMessage(Message msg) { // Process received messages } }; Looper.loop(); } } // ClientThread has a reference to the mHandler object // of ProcessingThread class ClientThread extends Thread { private void sendMessageExample() { Message msg = Message.obtain(mHandler, 1); msg.obj = \u0026#34;New message\u0026#34;; mHandler.sendMessage(msg); } private void sendRunnableExample() { mHandler.post(new Runnable() { @Override public void run() { // Task executed on ProcessingThread } }); } } HandlerThread In practice, developers rarely create and manage threads and Loopers manually. Android provides HandlerThread, a special type of thread with a built-in Looper property. You can retrieve its Looper using the getLooper() method.\n1 2 3 4 HandlerThread thread = new HandlerThread(\u0026#34;ProcessingThread\u0026#34;); thread.start(); Looper looper = thread.getLooper(); Handler handler = new Handler(looper); Main Thread The Main thread (UI thread) in Android already has a built-in Looper, which can be accessed via Looper.getMainLooper(). A common example is creating a Handler to delay a task on the UI thread, as follows:\n1 2 3 4 5 6 7 Handler handler = new Handler(Looper.getMainLooper()); handler.postDelayed(new Runnable() { @Override public void run() { // Delayed task } }, 3000); Conclusion Looper, MessageQueue, and Handler are essential components of Android’s asynchronous processing system. They work together to facilitate efficient and safe inter-thread communication. Understanding their operations can help you build robust Android applications. Thank you for reading!\nReference https://developer.android.com/reference/android/os/Looper https://developer.android.com/reference/android/os/MessageQueue https://developer.android.com/reference/android/os/Handler ","date":"2024-10-10T00:00:00+07:00","image":"https://namanh11611.github.io/p/looper-message-queue-handler/looper_message_queue_handler_hu2615633085704173998.jpg","permalink":"https://namanh11611.github.io/p/looper-message-queue-handler/","title":"All About Looper, MessageQueue, and Handler in Android"},{"content":"Photo by Felix Mittermeier on Unsplash\nGit Branching Strategy refers to the way we create branches, merge branches, and decide which branches are used for releases.\nWhen starting a project, beyond setting up the environment and building a solid codebase, selecting the right Git Branching Strategy is crucial. A wrong choice can lead to significant challenges. The right strategy helps the team manage and maintain source code effectively, reduce conflict resolution time, and ensure production code remains stable.\nOver time, various strategies have emerged. This article explores some popular Git Branching Strategies like Gitflow, GitHub Flow, GitLab Flow, and Trunk-Based Development. Finally, we’ll discuss how to choose the right strategy for your project.\nGitflow Gitflow, introduced by Vincent Driessen, is well-suited for projects with clear and complex release cycles. Gitflow uses multiple branch types to manage the development and release phases.\nIn this flow, there are two main branches: master and develop. The master branch contains stable code ready for release, while develop contains the latest changes for the next release. It’s the main branch for feature integration.\nAdditionally, there are feature branches that are checkout from develop and used to develop new features. Once completed, they are merge back into develop.\nWhen ready for release, a branch is checked out from develop to a release branch with the corresponding version to prepare for the release. Bug fixes can be added as commits on this branch. Once finalized, the release branch is merge into both master and develop to keep the two main branches updated.\nFinally, there are hotfix branches. When production code encounters a critical bug that needs an immediate fix, a hotfix branch is checkout from master for the fix. Similar to release branches, hotfix branches must also be merge into both master and develop.\nAdvantages Provides a clear structure, ideal for large projects. Efficiently manages development and release phases with versioned release branches. Hotfix branches allow quick fixes without disrupting ongoing development. Disadvantages Complex and requires multiple branches and merges. For example, each release or hotfix branch needs to be merged into both master and develop. Unsuitable for projects requiring CI/CD. Challenging for small teams due to its cumbersome nature. GitHub Flow GitHub Flow is a lightweight, simple strategy ideal for CI/CD and commonly used in open-source projects or small teams.\nUnlike Gitflow, it has a single main branch, main, which contains thoroughly tested and stable code ready for production.\nFeatures are developed in feature branches, tested, reviewed, and merged into main via pull requests.\nAdvantages Simple and easy to understand, making it quick to implement. Perfect for CI/CD workflows, ensuring the main branch is always deployable. Fewer branches mean reduced conflicts and merge errors. Disadvantages Lacks the structure of Gitflow. Unsuitable for large projects or those requiring support for multiple versions. Does not define clear processes for releases or bug fixes. GitLab Flow GitLab Flow combines elements of Gitflow and GitHub Flow. It introduces environment branches like staging and production, making it suitable for CI/CD and tightly integrated with GitLab’s CI/CD tools.\nSimilar to GitHub Flow, GitLab Flow works directly with the primary branch, main, which contains stable source code ready for release. This flow also includes feature branches for developing new features.\nWhen the code on the main branch is ready for testing, we merge it into the staging branch. After testing and confirming it is ready for deployment, we merge the code from the staging branch into the production branch. GitLab Flow often uses release branches, such as release/v1 and release/v2, to independently manage and deploy different versions of the application.\nHowever, when there is a bug in production, you need to merge the code into the main branch first, then merge or cherry-pick it into other branches following the above process.\nAdvantages Simpler than Gitflow, but more structured than GitHub Flow. Well-suited for CI/CD projects with multiple environments. Supports independent management of different application versions using release branches. Disadvantages Best suited for GitLab and its CI/CD tools. Requires careful setup to leverage its full potential. Not ideal for projects without CI/CD requirements. Trunk-Based Development For a detailed discussion, refer to my article: Trunk-Based Development - A Git Workflow to Reduce Merge Conflicts. Trunk-Based Development (TBD) is a strategy where all developers work on a single main branch, typically main. Changes are continuously and quickly committed to this branch, minimizing the lifespan of feature branches.\nAdvantages Encourages CI and minimizes merge conflicts. Ideal for Agile and DevOps projects requiring CD. Easy to manage and track the codebase. Disadvantages Higher risk of directly committing errors to the main branch. Requires robust code reviews and automation tests to maintain stability. Unsuitable for large, distributed teams. Choosing the Right Strategy There’s no one-size-fits-all solution. The choice of Git branching strategy depends on factors like project scale, team structure, and development requirements. Below are some suggestions:\nProject Type Team Size Recommended Strategy Small to medium projects with continuous delivery Small, Medium GitHub Flow, TBD Scheduled and periodic releases Medium GitFlow, GitLab Flow CI/CD projects with multiple environments Medium, Large GitLab Flow Long-term maintenance projects Large GitFlow Each strategy has its pros and cons. The key is selecting one that aligns with your team’s workflow and project requirements. Doing so optimizes productivity and minimizes risks in source code management.\nReferrence https://nvie.com/posts/a-successful-git-branching-model https://docs.github.com/en/get-started/using-github/github-flow https://about.gitlab.com/topics/version-control/what-is-gitlab-flow https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy https://www.geeksforgeeks.org/branching-strategies-in-git https://www.abtasty.com/blog/git-branching-strategies ","date":"2024-09-08T00:00:00+07:00","image":"https://namanh11611.github.io/p/git-branching-strategy/strategy_hu3976772075235522112.jpg","permalink":"https://namanh11611.github.io/p/git-branching-strategy/","title":"Gitflow, GitHub Flow, GitLab Flow, Trunk-Based Development: Which Git Branching Strategy is Right for You?"},{"content":"Photo by Ana Cruz on Unsplash\nTiếp nối serie Kotlin cheat sheet, chúng ta cùng đi đến với cheat sheet cuối cùng dành cho SharedFlow và StateFlow.\nSharedFlow và StateFlow là hai loại flow đặc biệt trong Kotlin Flow, cung cấp các tính năng mạnh mẽ cho việc chia sẻ trạng thái và sự kiện giữa các thành phần khác nhau trong ứng dụng. Trong phần cuối của loạt bài viết này, chúng ta sẽ tìm hiểu sâu về cách sử dụng SharedFlow và StateFlow, những lợi ích của chúng, và cách tích hợp vào ứng dụng Android của bạn để xử lý luồng dữ liệu một cách hiệu quả và mượt mà hơn.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow SharedFlow Nguyên tắc chính Là một hot stream. Có thể có nhiều receiver và tất cả chúng sẽ nhận được cùng một giá trị. Hữu ích khi bạn cần truyền các giá trị tới nhiều consumer hoặc muốn chia sẻ trạng thái/sự kiện giữa các phần khác nhau trong ứng dụng của mình. Không bao giờ hoàn thành cho đến khi chúng ta close toàn bộ scope. Có phiên bản có thể thay đổi MutableSharedFlow cho phép chúng ta cập nhật state bằng cách emit các giá trị mới với suspend function emit. Chúng ta cũng có thể sử dụng phiên bản non suspend tryEmit. Hỗ trợ cấu hình replay và tràn buffer. Tất cả các phương thức của shared flow đều thread-safe và có thể được gọi một cách an toàn từ các coroutine đồng thời mà không cần đồng bộ hóa bên ngoài. Các tham số cấu hình Kotlin đang cung cấp cho chúng ta một phương thức hữu ích để tạo MutableSharedFlow và xác định cách chúng ta muốn buffer hoạt động:\n1 2 3 4 5 6 7 8 9 public fun \u0026lt;T\u0026gt; MutableSharedFlow( // số lượng giá trị được replayed cho subscriber mới replay: Int = 0, // số lượng giá trị được lưu vào buffer ngoài `replay` extraBufferCapacity: Int = 0, // hành động khi tràn buffer // Các giá trị: SUSPEND, DROP_OLDEST, DROP_LATEST onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND ): MutableSharedFlow\u0026lt;T\u0026gt; shareIn Biến đổi Flow thành SharedFlow. Hữu ích khi chúng ta muốn biến một flow thành nhiều flow Yêu cầu coroutine scope làm tham số đầu tiên (scope) để bắt đầu coroutine và collect phần tử của flow. Tham số thứ hai started xác định thời điểm SharedFlow sẽ bắt đầu listen giá trị do flow emit. Nó lấy một object SharingStarted. Tham số thứ ba, replay, (mặc định là 0) xác định số lượng giá trị được replay cho subscriber mới. SharingStarted option SharingStarted.Eagerly: bắt đầu listen các phần tử ngay lập tức và không bao giờ dừng lại cho đến khi scope bị cancel. SharingStarted.Lazily: bắt đầu listen khi subscriber đầu tiên xuất hiện và không bao giờ dừng cho đến khi scope bị cancel. SharingStarted.WhileSubscribed(): bắt đầu listen khi subscriber đầu tiên xuất hiện và dừng ngay khi subscriber cuối cùng biến mất. Chúng ta config delay (tính bằng mili giây) giữa thời điểm subscriber cuối cùng biến mất và thời điểm dừng coroutine bằng tham số stopTimeoutMillis. Lưu ý về WhileSubscribed: nếu bạn mở một Intent mới từ màn hình của mình, chẳng hạn như ứng dụng máy ảnh, màn hình của bạn sẽ bị tạm dừng và do đó SharedFlow của bạn sẽ không còn subscriber nữa và sẽ ngừng emit. Khi quay lại màn hình ban đầu, bạn sẽ subscribe lại màn hình của mình và có thể chạy lại tác vụ bên trong flow của mình. Điều này có thể gây ra sự cố hoặc trigger lại một tác vụ không cần thiết.\nLưu ý về SharingStarted.Eagerly và SharingStarted.Lazily: nếu bạn đang sử dụng ViewModelScope hoặc LifecycleScope thì SharedFlow sẽ ngừng gửi các phần tử khi màn hình bị destroy.\nBiến flow thành SharedFlow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // từ một viewModel hoặc một class có lifeCycleScope myFlow.shareIn( scope = viewModelScope started = SharingStarted.Lazily ) // từ một class không có lifeCycleScope (repository hoặc use case) suspend fun myFunction() = coroutineScope { myFlow.shareIn( scope = this, started = SharingStarted.Lazily ) } Use case: Observe database thay đổi từ nhiều vị trí Nếu bạn sử dụng Room cho cơ sở dữ liệu của mình thì bạn có thể đã biết rằng nó đã hỗ trợ Flow. Vì vậy, bạn có thể observe các thay đổi trong database của mình và nhận dữ liệu mới ngay khi có. Nhưng việc đọc dữ liệu từ disk có thể khá nặng. Nếu cần nhận dữ liệu ở nhiều màn hình, bạn có thể sử dụng SharedFlow để tránh phải fetch dữ liệu cho mọi màn hình.\nTrong ví dụ này, mình sẽ trình bày cách để fetch một UserSettings một lần nhưng vẫn nhận được update trên nhiều màn hình:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // DAO đơn giản để fetch dữ liệu từ Room @Dao interface UserSettingsDao { // fetch tất cả user settings từ database và emit một flow @Query(\u0026#34;SELECT * FROM user_settings\u0026#34;) fun getAll(): Flow\u0026lt;List\u0026lt;UserSettings\u0026gt;\u0026gt; } class UserSettingsRepository @Inject constructor( private val dao: UserSettingsDao ) { // Chúng ta chỉ đọc từ DB một lần và tất cả receiver sẽ nhận được // data được tính toán ở đây. suspend fun getAll(): SharedFlow\u0026lt;List\u0026lt;UserSettings\u0026gt;\u0026gt; = coroutineScope { dao.getAll.shareIn( // truyền xuống scope scope = this, // chỉ bắt đầu emit khi chúng ta có receiver started = SharingStarted.Lazily, // replay phần tử mới nhất khi một receiver mới subscribe nó replay = 1 ) } } StateFlow Nguyên tắc chính Hoạt động tương tự như a SharedFlow với tham số replay được đặt thành 1. Luôn chỉ lưu trữ một giá trị. Giá trị được lưu trữ có thể được truy cập bằng thuộc tính value. Chúng ta cần đặt giá trị ban đầu trong constructor. Sự thay thế hiện đại cho LiveData. Sẽ không emit phần tử mới nếu nó bằng phần tử trước đó. Thiết lập và đọc một giá trị 1 2 3 4 val state = MutableStateFlow(\u0026#34;A\u0026#34;) // giá trị ban đầu là A state.value = \u0026#34;B\u0026#34; // đặt giá trị thành B state.value = \u0026#34;B\u0026#34; // giá trị này sẽ không emit phần tử mới vì giá trị đã là B val myValue = state.value // đọc giá trị từ state, ở đây là \u0026#34;B\u0026#34; stateIn Chuyển đổi một flow thành một StateFlow. Cần xác định scope. Có 2 loại, một loại suspend và một loại không suspend stateIn suspend suspend cho đến khi phần tử đầu tiên của flow được emit và giá trị mới được tính toán 1 2 3 suspend fun myFunction() = coroutineScope { myFlow.stateIn(this) } stateIn not suspend Yêu cầu một giá trị ban đầu trong tham số initialValue của nó. Tham số thứ hai của nó là started và mong đợi một phần tử SharingStarted. 1 2 3 4 5 myFlow.stateIn( scope = viewModelScope, started = SharingStarted.Lazily, initValue = \u0026#34;A\u0026#34; ) Use case: Emit data từ viewModel sang view Đoạn code về cách chuyển flow thành StateFlow để emit state từ view model sang view mà đang observe:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class MyViewModel @Inject constructor( private val fetchDataUseCase: FetchDataUseCase ) : ViewModel() { val myState: StateFlow\u0026lt;MyState\u0026gt; = fetchDataUseCase.dataState .map { when (it) { is FetchDataUseCase.FetchDataState.Loading -\u0026gt; MyState.Loading is FetchDataUseCase.FetchDataState.Success -\u0026gt; MyState.Success(it.data) is FetchDataUseCase.FetchDataState.Error -\u0026gt; MyState.Error(it.message) } } // chuyển flow thành state flow .stateIn( // đặt scope thành viewModel vì vậy chúng ta sẽ stop // listening khi viewModel bị destroy scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = MyState.Loading ) sealed interface MyState { data object Loading : MyState data class Success(val data: List\u0026lt;String\u0026gt;) : MyState data class Error(val message: String) : MyState } } @Composable fun MyScreen(viewModel = MyViewModel()) { val state = viewModel.myState.collectAsStateWithLifecycle() when (state) { is MyState.Loading -\u0026gt; // show loading view is MyState.Success -\u0026gt; // show success view is MyState.Error -\u0026gt; // show error view } } Cảm ơn bạn đã đồng hành cùng mình đến hết serie Kotlin cheat sheet này. Hy vọng những kiến thức hữu ích này sẽ giúp bạn tự tin hơn khi làm việc với Kotlin Coroutines và Flow.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T06:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-3/cheat_sheet_hu14006914972457270379.jpg","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-3/","title":"Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow"},{"content":"Photo by Ana Cruz on Unsplash\nTiếp nối serie Kotlin cheat sheet, chúng ta cùng đi đến với cheat sheet tiếp theo dành cho Flow.\nKotlin Flow là một API mạnh mẽ giúp quản lý luồng dữ liệu bất đồng bộ một cách rõ ràng và dễ dàng. Trong phần 2 này, chúng ta sẽ khám phá Flow từ cơ bản đến nâng cao, tìm hiểu cách tạo, chuyển đổi và thu thập các luồng dữ liệu, cũng như các best practice để áp dụng trong dự án Android của bạn.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow Flow Nguyên tắc chính Là một cold stream. Hỗ trợ sẵn structured concurrency. Tác vụ cuối cùng của flow được gọi là tác vụ terminal (collect, first… ). Một flow có thể có các tác vụ trung gian để sửa đổi flow (map, onEach, flatMapLastest… ). Terminal operation là suspend và yêu cầu một scope. Các Exception chưa được bắt sẽ ngay lập tức cancel một flow và collect sẽ throw lại Exception đó. Theo mặc định, context của flow sẽ lấy từ context mà collect được gọi. Kết hợp các flow với nhau merge, combine và zip là các hàm trung gian cho phép chúng ta kết hợp 2 (hoặc nhiều) flow thành 1. Vậy điểm khác biệt chính giữa 3 hàm đó là gì?\nmerge Không sửa đổi bất kỳ phần tử nào. Các phần tử được emit ngay khi chúng được tạo ra, chúng ta không đợi flow khác để tạo ra giá trị. Sử dụng nó khi bạn có nhiều nguồn event sẽ tạo ra cùng một action. flowA emit: 1\nflowB emit: 2\nflowA emit: 3\nmerge(flowA, flowB) tạo ra 1, 2, 3\nzip Kết hợp các phần tử từ các flow khác nhau để tạo ra giá trị mới. Chúng ta cần một hàm để xác định cách các phần tử được kết hợp với nhau. Chúng ta cần đợi mỗi flow emit một giá trị để có thể tạo cặp. Các phần tử chỉ có thể là một phần của một cặp. Các phần tử còn lại không có cặp sẽ bị mất. flowA emit: 1\nflowB emit: 2\nflowA emit: 4\nflowA.zip(flowB) {fA, fB -\u0026gt; fA + fB } tạo ra 3 (1+2 = 3, còn 4 từ flowA sẽ bị loại bỏ)\ncombine Kết hợp các phần tử từ các flow khác nhau để tạo ra giá trị mới. Chúng ta cần một hàm xác định cách các phần tử được kết hợp với nhau. Chúng ta cần đợi flow chậm hơn emit giá trị lần đầu tiên trước khi tạo phần tử mới. Khi một flow tạo ra một phần tử mới, nó sẽ thay thế phần tử trước đó và một giá trị mới sẽ được emit ngay lập tức (chúng ta không đợi mỗi flow emit một phần tử mới). flowA emit: 1\nflowB emit: 2\nflowA emit: 3\nflowA.combines(flowB) { fA, fB -\u0026gt; fA + fB } tạo ra 3 (1+2 = 3) rồi 5 (3+2 = 5, trong đó phần tử 3 đã thay thế cho 1 trước đó)\nSự khác biệt giữa fold và scan Cả fold và scan kết hợp tất cả các giá trị do một flow emit thành một phần tử bằng cách áp dụng thao tác kết hợp các giá trị lại với nhau.\nfold là một tác vụ terminal. Nó suspend cho đến khi flow hoàn thành và tạo ra giá trị cuối cùng scan là một tác vụ trung gian và tạo ra tất cả các giá trị trung gian 1 2 3 4 5 val myflow = flowOf(1, 2, 3, 4) myFlow.fold(0) { acc, newElement -\u0026gt; acc + newElement } // tạo ra 10 myFlow.scan(0) { acc, newElement -\u0026gt; acc + newElement } // tạo ra 1, 3 (1+2), 6 (3+3), 10 (6+4) flatMapConcat, flatMapMerge và flatMapLatest Chúng đều là những tác vụ trung gian Chúng biến đổi các phần tử được emit bởi flow ban đầu bằng cách áp dụng một flow khác lên phần tử đó và trả về một flow khác 1 myFlowA.flatMapConcat { fA -\u0026gt; myFlowB(fA) } // giá trị trả về do flow B tạo ra flatMapConcat Chuyển đổi từng giá trị được emit thành một flow và nối các flow kết quả một cách tuần tự. Emit hoàn toàn các giá trị từ inner flow đầu tiên trước khi bắt đầu flow tiếp theo. Use Case: khi bạn cần xử lý các flow bên trong theo thứ tự, không bị chồng chéo. flatMapMerge Chuyển đổi từng giá trị được emit thành một flow và hợp nhất các flow kết quả một cách đồng thời. Emit các giá trị từ tất cả các inner flow khi chúng có sẵn, có khả năng không theo thứ tự. Use Case: khi bạn muốn xử lý đồng thời các flow bên trong và không quan tâm đến thứ tự của các giá trị được emit. flatMapLatest Chuyển đổi từng giá trị được emit thành một flow, hủy các flow trước đó khi một giá trị mới đã được emit, và emit các giá trị từ flow mới nhất. Chỉ flow mới nhất được hoạt động và các giá trị của nó được emit. Các flow trước đó bị hủy bỏ. Use Case: khi bạn chỉ quan tâm đến giá trị mới nhất và muốn hủy các thao tác trước đó. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 data class User(val id: Int, val name: String) data class UserDetails(val userId: Int, val address: String) fun fetchUserData(): Flow\u0026lt;User\u0026gt; = flow { emit(User(1, \u0026#34;Alice\u0026#34;)) delay(500) emit(User(2, \u0026#34;Bob\u0026#34;)) delay(500) emit(User(3, \u0026#34;Charlie\u0026#34;)) } fun fetchUserDetails(userId: Int): Flow\u0026lt;UserDetails\u0026gt; = flow { delay(1000) // Giả lập network delay emit(UserDetails(userId, \u0026#34;$userId\u0026#39;s address\u0026#34;)) } // flatMapConcat fetchUserData() .flatMapConcat { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapConcat: ${userDetails}\u0026#34;) } // Mỗi thông tin user được trả về tuần tự. // flatMapConcat: UserDetails(userId=1, address=1\u0026#39;s address) // flatMapConcat: UserDetails(userId=2, address=2\u0026#39;s address) // flatMapConcat: UserDetails(userId=3, address=3\u0026#39;s address) // flatMapMerge fetchUserData() .flatMapMerge { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapMerge: ${userDetails}\u0026#34;) } // Thông tin user có thể bị xen kẽ do trả về đồng thời. // flatMapMerge: UserDetails(userId=1, address=1\u0026#39;s address) // flatMapMerge: UserDetails(userId=2, address=2\u0026#39;s address) // flatMapMerge: UserDetails(userId=3, address=3\u0026#39;s address) // flatMapLatest fetchUserData() .flatMapLatest { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapLatest: ${userDetails}\u0026#34;) } // Chỉ thông tin của user cuối cùng được trả về // do user mới sẽ cancel fetch trước đó. // flatMapLatest: UserDetails(userId=3, address=3\u0026#39;s address) Chuyển đổi function thành Flow 1 2 3 4 5 6 val function = suspend { // đây là biểu thức lambda suspend // định nghĩa hàm ở đây } function.asFlow() Hoặc\n1 2 3 4 5 suspend fun myFunction(): Flow\u0026lt;T\u0026gt; { // định nghĩa hàm ở đây } ::myFunction.asFlow() Tạo flow tạo ra các phần tử trước khi chúng ta subscribe Hàm channelFlow tạo ra sự kết hợp giữa flow và channel. Nó tạo ra một hot stream data nhưng cũng implement Flow interface.\n1 2 3 4 5 6 7 8 val myChannelFlow = channelFlow { val myData = // fetch dữ liệu tại đây send(myData) } suspend fun fetchData() { myData.first() } Sửa đổi context của Flow 1 2 3 4 5 myFlow.flowOn(Dispatchers.IO) // Hoặc myFlow.flowOn(CoroutineName( \u0026#34;NewName\u0026#34; )) Tránh lồng nhau khi khởi chạy flow 1 2 3 4 5 6 7 // thay vì viewModelScope.launch { myFlow.collect() } // làm như này myFlow.launchIn(viewModelScope) Cảm ơn các bạn đã đọc đến đây, cùng chờ đón những phần tiếp theo nhé.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T05:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-2/cheat_sheet_hu14006914972457270379.jpg","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-2/","title":"Kotlin Flow cheat sheet phần 2: Flow"},{"content":"Photo by Ana Cruz on Unsplash\nSau khi làm việc với Kotlin Flows một thời gian, có thể bạn đã quen với các khái niệm cơ bản. Nhưng nếu chưa bao giờ sử dụng Channel, bạn sẽ không biết sự khác nhau giữa merge, combine và zip, hoặc có thể bạn chưa hiểu rõ SharedFlow và StateFlow cũng như cách sử dụng chúng.\nCheat sheet này hệ thống lại những kiến thức quan trọng mà mình đã góp nhặt được trong quá trình làm việc với Kotlin Flow. Nó được thiết kế để trở thành một tài liệu tham khảo hữu ích, giúp bạn giải quyết các tình huống phức tạp.\nTrong phần 1, chúng ta sẽ tìm hiểu chi tiết về Channel, cách thức hoạt động, và cách ứng dụng trong các trường hợp thực tế để giao tiếp giữa các coroutine một cách an toàn và hiệu quả.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow Hot streams và Cold streams Hot streams Ví dụ: channel, Collections (List, Set… ). Bắt đầu ngay lập tức: bắt đầu emit các giá trị bất kể có subscriber hay không. Lưu các phần tử: chúng không cần phải tính toán lại và tất cả subscriber đều nhận được cùng một chuỗi giá trị. Cold streams Ví dụ: Sequence, Flow Bắt đầu theo yêu cầu: cold streams chỉ bắt đầu emit các giá trị khi subscriber chủ động đăng ký stream đó. Nguồn dữ liệu là lazy. Phát độc lập: mỗi subscriber nhận được chuỗi giá trị độc lập của riêng mình. Không có phần tử nào được lưu trữ. Channel Nguyên tắc chính Là một hot stream. Đảm bảo không có xung đột (không có vấn đề với trạng thái chia sẻ) và công bằng nên rất hữu ích khi các coroutine khác nhau cần liên lạc với nhau. Hỗ trợ bất kỳ số lượng sender và receiver. Mỗi giá trị gửi tới channel chỉ được nhận một lần. Nếu có nhiều receiver subscribe cùng lúc, các phần tử sẽ được phân bổ công bằng giữa các receiver. (Hàng đợi FIFO của receiver). Channel có 3 receiver, subscribe theo thứ tự: Receiver1, Receiver2, Receiver3.\nTất cả receiver đã subscribe channel.\nChannel emit ra 4 giá trị: \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;C\u0026rdquo; rồi \u0026ldquo;D\u0026rdquo;.\nReceiver1 nhận được \u0026ldquo;A\u0026rdquo; và \u0026ldquo;D\u0026rdquo;\nReceiver2 nhận được \u0026ldquo;B\u0026rdquo;\nReceiver3 nhận được \u0026ldquo;C\u0026rdquo;\nChúng có 2 suspend function là send và receive. receive bị suspend nếu không có phần tử nào trong channel và sẽ đợi một phần tử sẵn sàng để tiếp tục. send bị suspend nếu channel đạt đến capacity. Chúng ta cũng có thể sử dụng phiên bản không bị suspend là trySend và tryReceive, chúng trả về một ChannelResult (cho chúng ta biết thao tác có thành công hay không). Chúng cần được close thủ công sau khi chúng ta gửi xong dữ liệu hoặc khi xảy ra Exception: myChannel.close(). Nếu không, receive sẽ đợi các phần tử mãi mãi. Các loại channel capacity 1 2 3 4 5 6 7 val myChannel = Channel\u0026lt;Int\u0026gt;(capacity = 3) // hoặc val myChannel = produce(capacity = 3) { // emit các giá trị ở đây } Channel.UNLIMITED: buffer không giới hạn và send không bao giờ bị suspend. Channel.BUFFERED: buffer capacity là 64. Giá trị mặc định này có thể được override bằng thuộc tính hệ thống kotlinx.coroutines.channels.defaultBuffer trong JVM. Channel.RENDEZVOUS: (behavior mặc định) buffer capacity là 0. Receiver sẽ chỉ nhận được dữ liệu nếu nó đã subscribe với sender khi dữ liệu được emit. Channel.CONFLATED: buffer capacity là 1. Mỗi phần tử mới sẽ thay thế phần tử trước đó. Giá trị intbất kỳ: buffer sẽ có capacity bằng giá trị được set. Xử lý lỗi tràn buffer Các channel có một tham số onBufferOverflow kiểm soát những gì xảy ra khi buffer đầy. Có 3 lựa chọn:\nBufferOverflow.SUSPEND: (behavior mặc định) tạm dừng phương thức send khi buffer đầy. BufferOverflow.DROP_OLDEST: loại bỏ phần tử cũ nhất khi buffer đầy. BufferOverflow.DROP_LATEST: loại bỏ phần tử mới nhất khi buffer đầy. Tạo Channel tự động close Coroutine builder produce sẽ close channel bất cứ khi nào builder coroutine kết thúc (finish, stop hoặc cancel).\n1 2 3 4 5 suspend fun myFunction() = coroutineScope { val channel = produce { // emit các giá trị ở đây và không cần gọi close() khi kết thúc } } Tự động dọn dẹp nếu một phần tử không thể xử lý Nếu channel đã bị close, cancel hoặc khi send, receive, hastNext có lỗi\n1 2 3 4 val myChannel = Channel( capacity, onUnderliveredElement = { /* các tác vụ dọn dẹp ở đây */ } ) Use case: trigger một refresh Trong Android, trường hợp sử dụng phổ biến cho các channel là trigger khi một screen được refresh (pull to refresh hoặc button retry). Đoạn code bên dưới trình bày cách fetch data từ API khi chúng ta subscribe flow lần đầu tiên hoặc khi trigger một refresh.\nRất nhiều người sử dụng SharedFlow để trigger refresh và nó hoạt động ổn, nhưng đó không phải là giải pháp tốt nhất vì SharedFlow được thiết kế để có nhiều receiver.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Đây là phiên bản đơn giản hóa để minh họa cách chúng ta có thể sử dụng channel. // Trong trường hợp sử dụng thực tế, chúng ta sẽ yêu cầu một số logic bổ sung để tránh // làm mới nếu dữ liệu đã được tải chẳng hạn. interface ApiService { suspend fun fetchData(): List\u0026lt;String\u0026gt; } class FetchDataUseCase @Inject constructor ( private val apiService: ApiService ) { // tạo một channel có buffer là 1 và sẽ loại bỏ dữ liệu mới nhất // vì vậy nếu chúng ta trigger refresh nhiều lần liên tiếp // chúng ta sẽ chỉ giữ phần tử đầu tiên. private val refreshChannel = Channel\u0026lt;Unit\u0026gt;( capacity = 1, onBufferOverflow = BufferOverflow.DROP_LATEST ) // viewModel có thể receive flow này để build UI state val dataState: Flow\u0026lt;FetchDataState\u0026gt; = refreshChannel // convert channel thành flow .consumeAsFlow() // emit một phần tử khi bắt đầu fetch data ngay khi chúng ta subscribe flow .onStart { emit(Unit) } .map { fetchData() } fun refresh() { // Chúng ta sử dụng trySend ở đây để không phải tạo suspend function // và vì vậy chúng ta không cần scope để gọi nó. // Phương thức này có thể được gọi từ viewModel để trigger refresh refreshChannel.trySend(Unit) } private suspend fun fetchData(): FetchDataState = try { val data = apiService.fetchData() FetchDataState.Success(data) } catch (e: Exception) { FetchDataState.Error(e.message ?: \u0026#34;An error occurred\u0026#34;) } sealed interface FetchDataState { data object Loading : FetchDataState data class Success(val data: List\u0026lt;String\u0026gt;) : FetchDataState data class Error(val message: String) : FetchDataState } } Cảm ơn các bạn đã đọc đến đây, cùng chờ đón những phần tiếp theo nhé.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T04:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-1/cheat_sheet_hu14006914972457270379.jpg","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-1/","title":"Kotlin Flow cheat sheet phần 1: Channel"},{"content":"Photo by Ana Cruz on Unsplash\nSau khi làm việc với Kotlin Coroutines một thời gian, có thể anh em đã quen với các khái niệm cơ bản như suspend function và các hàm launch, async\u0026hellip;, có thể giải quyết các use case đơn giản một cách ngon ơ. Nhưng khi dự án trở nên phức tạp hơn, anh em có thể thường xuyên cần các giải pháp nâng cao hơn và phải nhờ sự trợ giúp đến từ Google hoặc AI.\nCheat sheet này hệ thống lại những kiến thức quan trọng mà mình đã góp nhặt được trong quá trình làm việc với Kotlin Coroutines. Nó được thiết kế để trở thành một tài liệu tham khảo hữu ích, giúp anh em giải quyết các trường hợp phức tạp của coroutine.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow Các khái niệm trong Coroutines Coroutine Context: tập hợp các thành phần khác nhau. Trong đó, các thành phần chính là Job và Dispatcher của coroutine.\nJob: thứ có thể hủy được với vòng đời đạt đến đỉnh khi nó hoàn thành. Mỗi coroutine đều tạo một Job của riêng nó (đó là coroutine context duy nhất không được kế thừa từ coroutine cha).\nDispatcher: cho phép chúng ta quyết định thread nào (hoặc pool của thread) mà coroutine sẽ chạy trên đó (khi start và resume). Bạn có thể đọc bài viết chi tiết của mình về Dispatchers trong Kotlin Coroutines\nCoroutine scope: xác định thời gian tồn tại và context của coroutine. Nó chịu trách nhiệm quản lý vòng đời của coroutine, bao gồm cả việc hủy và xử lý lỗi.\nCoroutine builder: các extension function của CoroutineScope, cho phép chúng ta start một coroutine bất đồng bộ (ví dụ như launch, async… ).\nCác quy tắc chính của Coroutines Bạn cần một CoroutineScope để start một coroutine (với function launch hoặc async). viewModelScope được sử dụng phổ biến nhất trong Android, nhưng bạn cũng có thể tự xây dựng scope của riêng bạn. Coroutine con (một coroutine bắt đầu từ một coroutine khác) kế thừa coroutine context từ coroutine cha (ngoại trừ Job). Job của coroutine cha được sử dụng làm cha của Job của coroutine con. Coroutine cha suspend cho đến khi tất cả các coroutine con của nó kết thúc. Khi một coroutine cha bị hủy thì tất cả các coroutine con của nó cũng bị hủy. Khi một coroutine con bị lỗi vì một Exception chưa được xử lý, nó sẽ cancel coroutine cha của nó (trừ khi bạn sử dụng một SupervisorJob). Bạn không nên sử dụng GlobalScope, nó có thể gây memory leak và giữ coroutine tồn tại ngay cả sau khi Activity hoặc Fragment khởi chạy nó đã bị bỏ qua. Bạn không nên truyền coroutine scope như một tham số, thay vào đó hãy sử dụng function coroutineScope. Các function của Coroutine scope coroutineScope: suspend function, dùng để bắt đầu một scope và trả về giá trị do tham số của function tạo ra. supervisorScope: tương tự coroutineScope nhưng nó override Job của context, vì vậy function không bị cancel khi coroutine con throw một Exception. withContext: tương tự coroutineScope nhưng cho phép thực hiện một số thay đổi trong scope (thường được sử dụng để set Dispatcher). withTimeout: tương tự coroutineScope nhưng đặt giới hạn thời gian cho phần body và nếu quá lâu sẽ bị hủy. Throw một TimeoutCancellationException. withTimeoutOrNull: tương tự withTimeout nhưng sẽ trả về null thay vì throw Exception khi hết thời gian. Chạy song song Khi bạn muốn thực hiện hai tác vụ cùng lúc và đợi kết quả của cả hai trước khi trả về kết quả:\nKhi bạn có quyền truy cập vào một scope (ví dụ từ ViewModel) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun getConfigFromAPI(): UserConfig { // thực hiện lệnh gọi API tại đây hoặc bất kỳ suspend fun nào } suspend fun getSongsFromAPI(): List\u0026lt;Song\u0026gt; { // thực hiện lệnh gọi API tại đây hoặc bất kỳ suspend fun nào } fun getConfigAndSongs() { // scope có thể là bất kỳ scope nào bạn muốn, trường hợp điển hình sẽ là viewModelScope scope.launch { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI() } return Pair(userConfig.await(), songs.await()) } } Giả sử bạn có API được phân trang và bạn muốn tải xuống tất cả các trang trước khi hiển thị chúng cho người dùng, nhưng bạn muốn tải song song tất cả các trang:\n1 2 3 4 5 6 7 8 9 10 11 12 13 suspend fun getSongsFromAPI(page: Int): List\u0026lt;Song\u0026gt; { // thực hiện lệnh gọi API } const val totalNumberOfPages = 10 fun getAllSongs() { // scope có thể là bất kỳ scope nào bạn muốn, trường hợp điển hình là viewModelScope scope.launch { val allNews = (0 until totalNumberOfPages) .map { page -\u0026gt; async { getSongsFromAPI(page) } } .flatMap { it.await } } } Lưu ý về async/await: coroutine sẽ được bắt đầu ngay lập tức khi nó được gọi. async trả về một object thuộc loại Deferred\u0026lt;T\u0026gt; (trong ví dụ của chúng ta là Deferred\u0026lt;List\u0026lt;Song\u0026gt;\u0026gt;). Deferred có suspend function await trả về giá trị khi nó sẵn sàng.\nKhi bạn không có quyền truy cập vào một scope (ví dụ từ một repository) Từ repository hoặc use case của bạn, bạn muốn định nghĩa một coroutine sẽ bắt đầu song song 2 (hoặc nhiều) lệnh gọi. Vấn đề là bạn cần một scope để sử dụng async nhưng bạn không ở trong viewModel hoặc presenter nên bạn không có quyền truy cập vào scope của mình ở đây (hãy nhớ quy tắc của chúng ta là không nên truyền scope như một tham số).\nTừ ví dụ ở trên, chúng ta sửa lại một chút như sau:\n1 2 3 4 5 suspend fun getConfigAndSongs(): Pair\u0026lt;UserConfig, List\u0026lt;Song\u0026gt; = coroutineScope { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI()} Pair(userConfig.await(), songs.await()) } Dọn dẹp khi Coroutine bị cancel Nếu một coroutine bị hủy thì nó sẽ có trạng thái cancelling trước khi chuyển sang cancelled. Khi một coroutine bị hủy, chúng ta sẽ có thời gian để thực hiện một số tác vụ dọn dẹp nếu cần thiết (chẳng hạn như dọn dẹp local database hoặc gọi API để cho server biết rằng tác vụ không thành công).\nChúng ta có thể sử dụng finally để thực hiện một tác vụ:\n1 2 3 4 5 6 7 viewModelScope.launch { try { // gọi một số suspend function tại đây } finally { // thực hiện tác vụ dọn dẹp tại đây } } Nhưng không được phép gọi suspend function trong quá trình dọn dẹp. Nếu bạn cần gọi suspend function, bạn sẽ cần phải làm như sau:\n1 2 3 4 5 6 7 8 9 viewModelScope.launch { try { // gọi một số suspend function tại đây } finally { withContext(NonCancellable) { // thực hiện suspend function dọn dẹp tại đây } } } Lưu ý: Việc cancel sẽ xảy ra tại điểm suspend đầu tiên. Vì vậy việc cancel sẽ không xảy ra nếu chúng không có bất kỳ suspend function nào.\nDọn dẹp Coroutine khi hoàn thành Tương tự như việc dọn dẹp khi một coroutine bị hủy, bạn có thể muốn thực hiện một thao tác khi coroutine đạt đến trạng thái cuối cùng (completed hoặc cancelled).\n1 2 3 4 5 6 suspend fun myFunction() = coroutineScope { val job = launch { /* suspend function tại đây */ } job.invokeOnCompletion { exception: Throwable -\u0026gt; // do something here } } Làm cách nào để KHÔNG cancel Coroutine khi một trong các phần tử con của nó bị lỗi Bạn có thể sử dụng SupervisorJob và nó sẽ bỏ qua tất cả các exception ở con của nó.\nTạo coroutine scope của bạn 1 2 3 4 val scope = CoroutineScope(SupervisorJob()) // nếu một coroutine mắc lỗi thì coroutine còn lại sẽ không bị hủy scope.launch { myFirstCoroutine() } scope.launch { mySecondCoroutine() } Sử dụng scope function 1 2 3 4 5 suspend fun myFunction() = supervisorScope { // nếu một coroutine xảy ra lỗi thì coroutine kia sẽ không bị hủy launch { myFirstCoroutine() } launch { mySecondCoroutine() } } Bắt exception 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun myFunction() { try { coroutineScope { launch { myFirstCoroutine() } } } catch (e: Exception) { // xử lý lỗi tại đây } try { coroutineScope { launch { mySecondCoroutine() } } } catch (e: Exception) { // xử lý lỗi tại đây } } CancellationException không truyền tới coroutine cha, chỉ coroutine hiện tại bị cancel. Có thể kế thừa CancellationException để tạo loại exception của riêng bạn, và nó cũng sẽ không truyền tới coroutine cha.\nĐịnh nghĩa tác vụ mặc định trong trường hợp có exception Chúng ta có thể sử dụng CoroutineExceptionHandler. Ví dụ, dùng để tự động đăng xuất người dùng khi server trả về lỗi 401.\n1 2 3 4 5 6 val handler = CoroutineExceptionHandler { context, exception -\u0026gt; // định nghĩa tác vụ mặc định như hiển thị hộp thoại hoặc thông báo lỗi } val scope = CoroutineScope(SupervisorJob() + handler) scope.launch { /* gọi suspend function tại đây */ } scope.launch { /* gọi suspend function tại đây */ } Chạy một tác vụ không cần thiết Nếu bạn muốn chạy một suspend function mà không ảnh hưởng đến các function khác (ví dụ nếu nó gây ra lỗi thì chỉ hàm này sẽ KHÔNG cancel coroutine, nhưng các hàm khác nếu gây ra lỗi thì vẫn sẽ cancel coroutine bình thường). Ví dụ điển hình là các function analytics.\n1 2 3 4 5 6 7 val nonEssentialOperationScope = CoroutineScope(SupervisorJob()) suspend fun getConfigAndSongs(): Pair\u0026lt;UserConfig, List\u0026lt;Song\u0026gt; = coroutineScope { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI()} nonEssentialOperationScope.launch { /* tác vụ không cần thiết ở đây */ } Pair(userConfig.await(), songs.await()) } Lý tưởng nhất là bạn nên inject nonEssentialOperationScope vào class để dễ test hơn.\nChạy một tác vụ trên single thread để tránh các sự cố đồng bộ 1 2 3 4 suspend fun myFunction() = withContext(Dispatchers.Default.limiteParallelism(1)) { // suspend function tại đây } // Cũng có thể sử dụng Dispatchers.IO Các cách tiếp cận khác để tránh sự cố đồng bộ hóa với multithreading Bạn có thể sử dụng AtomicReference (từ Java)\n1 2 3 4 5 6 private val myList = AtomicReference(listOf( /* thêm object vào đây */ )) suspend fun fetchNewElement() { val myNewElement = // fetch phần tử mới tại đây myList.getAndSet { it + myNewElement } } Hoặc với Mutex\n1 2 3 4 5 6 7 8 9 val mutex = Mutex() private var myList = listOf( /* thêm object vào đây */ ) suspend fun fetchNewElement() { mutex.withLock { val myNewElement = // fetch phần tử mới tại đây myList += myNewElement } } Tránh gửi lại một coroutine đến cùng một dispatcher Tránh chi phí không cần thiết khi chuyển đổi dispatcher nếu chúng ta đã sử dụng Dispatcher.Main:\n1 2 3 4 // điều này sẽ chỉ dispatch nếu cần thiết suspend fun myFunction() = withContext(Dispatcher.Main.immediate) { // suspend fun tại đây } Hiện tại chỉ Dispatchers.Main hỗ trợ immediate dispatching.\nCảm ơn bạn đã đọc đến đây. Nếu bạn có kiến thức hay ho hoặc tip về Kotlin Coroutines, đừng ngần ngại comment chia sẻ với mình nhé!\nReference https://medium.com/@galou.minisini/advanced-kotlin-coroutine-cheat-sheet-for-android-engineer-15e0d180fc1f ","date":"2024-08-12T00:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-coroutines-cheat-sheet/cheat_sheet_hu14006914972457270379.jpg","permalink":"https://namanh11611.github.io/p/kotlin-coroutines-cheat-sheet/","title":"Kotlin Coroutines cheat sheet nâng cao dành cho Android Engineer"},{"content":"Photo by Ashley Batz on Unsplash\nThe Journey Begins LeetCode is likely familiar to many of you—a platform for solving algorithm problems and preparing for coding interviews, especially for foreign companies and a few in Vietnam.\nI started my journey the same way, simply to prepare for interviews. I realized that practicing problems on LeetCode not only improved my coding skills but also gave me more confidence when facing algorithm and data structure-related interview questions.\nI began solving problems by topic. This approach helped me systematically organize my knowledge and master specific types of problems. By focusing on one topic at a time, I could deepen my understanding and solve problems more efficiently. Since I didn’t specialize in Computer Science and didn’t participate in algorithm competitions during university, I could manage problems involving BFS, DFS, Hash Table, Stack, or Queue, but initially struggled with topics like Dynamic Programming and Union Find. However, as the saying goes, \u0026ldquo;Practice makes perfect\u0026rdquo;, after solving about ten problems, it became much easier.\nIn this initial phase, I solved around 100 problems, which I found sufficient to interview with companies that typically ask easy-to-medium-level questions.\nSustaining as a Hobby After passing my interview and joining a good company, I stopped solving problems for about a year. Then, on a beautiful day, I felt inspired to pick it up again. During this second phase, I treated solving LeetCode problems as a daily hobby. I spent around 30 minutes a day solving one problem from the Daily Coding Challenge. This not only helped maintain my algorithm skills but also served as a form of relaxation and self-challenge. Moreover, solving random problems daily better mimicked real-life interview scenarios.\nI usually set a 30-minute timer, and if I couldn’t figure out a solution, I’d read the Editorial (solutions provided by LeetCode), then try to memorize and code it myself. After every problem, whether solved independently or with help, I would check the Solutions section to see how others approached it. The top-voted solutions often showcased creative and optimized methods, sometimes even better than the Editorial solutions.\nAs the saying goes, \u0026ldquo;If you want to go fast, go alone. If you want to go far, go together.\u0026rdquo; To find companions and exchange experiences, I frequently joined discussions on the voz forum. This not only motivated me but also allowed me to learn various approaches from the community. To maintain motivation, I set a specific goal: reaching 6000 points to earn the LeetCode T-shirt. Setting clear goals gave me a reason to keep pushing forward every day.\nAchieving the Goal and Deciding to Pause After about 1.5 years of consistent effort, on July 26, 2024, I finally achieved my goal of 6000 points and claimed the T-shirt.\nHowever, with work becoming busier, I decided to take a break and focus on current responsibilities. Interestingly, the number of problems I solved happened to be 555—a perfect milestone. Maybe it’s a signal from the universe.\nWhen working with Thai colleagues, I learned that 555 in Thai is pronounced like laughter, Hahaha. Isn’t this universal signal quite amusing?\nTaking a break doesn’t mean giving up. In the future, if I feel inspired or need to prepare for companies that demand higher algorithm expertise, I’ll return to solving problems. The journey of solving 555 LeetCode problems has significantly enhanced my programming skills and logical thinking.\nWishing you all an energetic week ahead!\n","date":"2024-07-28T00:00:00+07:00","image":"https://namanh11611.github.io/p/leetcode/leetcode_hu3435752111166744917.jpg","permalink":"https://namanh11611.github.io/p/leetcode/","title":"Journey of Solving 555 LeetCode Problems"},{"content":"Introduction Process is a fundamental but essential concept in Android. When we launch an application, by default, all components like Activity, Service, BroadcastReceiver, and ContentProvider run within a single Linux Process unless we specify a separate process in the AndroidManifest file, as shown below:\n1 2 3 4 \u0026lt;activity android:process=\u0026#34;new_process_name\u0026#34; ...\u0026gt; \u0026lt;/activity\u0026gt; By default, the process name matches the app ID declared in the build.gradle file. Both the application and the four main components have an android:process tag. Therefore, if you declare android:process for the \u0026lt;application\u0026gt; tag, that process name will apply to all components of that application.\nPriority Levels We cannot manage Process lifetime directly. Android automatically calculates which components of running applications are active, their importance to the user, and the remaining memory to decide the Process lifetime.\nWhen Android runs out of resources, it shuts down a Process, and naturally, the components running on that Process are destroyed as well. What determines which Process gets shut down?\nAndroid prioritizes Processes based on their importance to the user. It classifies Processes into four priority levels:\nForeground Process This is the highest priority Process. It contains components the user is actively interacting with, such as:\nActivity at the top of the screen that the user is engaging with, where the onResume() method has been called. BroadcastReceiver running, with its onReceive() method currently executing. Service executing code in one of its callbacks: onCreate(), onStart(), or onDestroy(). Only a few Processes like this exist in the system, and they are only killed when memory is so low that even these cannot continue running.\nVisible Process This Process performs tasks that the user is aware of. If killed, it would impact the user experience. Examples include:\nActivity displayed on the screen but not in the foreground, where the onPause() method has been called. For example, an Activity partially covered by a dialog. Foreground Service running via the startForeground() method, making it visible to the user. A service running a feature visible to the user, such as a live wallpaper or keyboard. Service Process This Process contains a Service running via the startService() method. The user does not see it directly but is aware of the tasks it performs, such as uploading or downloading data in the background.\nA long-running Service (e.g., more than 30 minutes) may have its importance reduced to a cached state.\nCached Process These Processes are no longer necessary, and the system can safely kill them without hesitation when more resources are required.\nAn efficient system will have many Cached Processes to facilitate smooth app transitions and frequently kill Cached apps when needed.\nAndroid uses LRU Cache (Least Recently Used Cache) to manage Cached Processes, prioritizing the removal of Processes least recently used.\nIn summary, understanding how components like Activity, Service, and BroadcastReceiver impact priority levels is crucial. Select the appropriate component for your use case to avoid a Process being killed during important tasks.\nInter-Process Communication (IPC) Inter-Process Communication, or IPC, is a mechanism that allows Processes to communicate and synchronize their actions in Android.\nEach app runs in a separate Process, but many apps need to communicate with each other to share data or perform collaborative tasks, making IPC essential for safe and efficient inter-Process communication.\nIntent Intent is the standard mechanism for asynchronous communication between Activities and BroadcastReceivers. Depending on the need, you can use sendBroadcast, sendOrderedBroadcast, or explicit intents.\nAndroid Interface Definition Language (AIDL) AIDL is a tool for defining interfaces between Android applications. It enables apps to communicate safely and efficiently, regardless of the programming languages they are written in.\nMessenger Messenger is a class in the Android SDK that allows applications to send and receive messages. It provides a simple interface for inter-application communication.\nThe main difference between AIDL and Messenger is that AIDL supports concurrent tasks, while Messenger is limited to sequential tasks.\nBroadcast Receiver BroadcastReceiver handles asynchronous requests from Intents. By default, any app can call the receiver. If you intend to use BroadcastReceiver for a specific application, you can secure it by using the \u0026lt;receiver\u0026gt; tag in the AndroidManifest. This prevents unauthorized apps from sending Intents to the BroadcastReceiver.\nReference https://developer.android.com/guide/components/processes-and-threads https://developer.android.com/guide/components/activities/process-lifecycle https://developer.android.com/privacy-and-security/security-tips#interprocess-communication ","date":"2024-06-21T00:00:00+07:00","image":"https://namanh11611.github.io/p/process/process_hu7001084372127928409.jpg","permalink":"https://namanh11611.github.io/p/process/","title":"Everything About Process in Android"},{"content":"Có thể nói, trong quá trình làm LeetCode thì Dynamic Programming (DP), hay còn gọi là Quy hoạch động trong tiếng Việt, là một dạng bài mọi người thường xuyên gặp nhất, nhưng cũng là một trong những dạng khó nhằn nhất. Khi gặp một bài mới, nếu bạn nhận ra nó có thể giải bằng DP là bạn đã đi được 80% quãng đường rồi. Vậy nên, để giúp cho quá trình \u0026ldquo;nhận ra\u0026rdquo; đấy trở nên dễ dàng hơn, trong bài viết này, mình sẽ chia sẻ với các bạn 5 dạng phổ biến của DP trên LeetCode.\nTìm giá trị nhỏ nhất / lớn nhất Đề bài thường có dạng:\nCho một mục tiêu, tìm giá trị nhỏ nhất / lớn nhất để đạt mục tiêu đó.\nHướng giải:\nTìm giá trị nhỏ nhất / lớn nhất trong số tất cả các cách có thể trước đó, sau đó cộng với giá trị của trạng thái hiện tại.\n1 routes[i] = min(routes[i-1], ... , routes[i-k]) + cost[i] Khi giải một bài DP, chúng ta có 2 hướng làm là Top-Down và Bottom-Up.\nTheo hướng tiếp cận Top-Down, chúng ta sẽ bắt đầu bằng bài toán lớn nhất hay là bài toán ở mức trên cùng sau đó dùng phương pháp đệ quy để gọi lời giải cho các bài toán con ở mức thấp hơn tiếp theo. Quá trình tiếp tục cho đến khi gặp bài toán nhỏ nhất. Đệ quy sẽ tự động tổ hợp kết quả của các bài toán con để được kết quả bài toán ban đầu. Chúng ta thường sẽ dùng một mảng memo để lưu kết quả các bài toán con, tránh việc phải tính đi tính lại chúng gây ra lỗi Time Limit Exceeded.\n1 2 3 4 for (int j = 0; j \u0026lt; ways.size(); ++j) { result = min(result, topDown(target - ways[j]) + cost[i]); } return memo[/*state parameters*/] = result; Còn theo hướng Bottom-Up, chúng ta sẽ giải các bài toán con ở mức thấp nhất, sau đó dùng các kết quả này để tính bài toán ở mức trên. Quá trình tiếp tục cho đến khi chúng ta tìm được kết quả bài toán mức cao nhất. Cá nhân mình thì thường làm theo hướng nay hơn.\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= target; ++i) { for (int j = 0; j \u0026lt; ways.size(); ++j) { if (ways[j] \u0026lt;= i) { dp[i] = min(dp[i], dp[i - ways[j]] + cost[i]); } } } return dp[target] Chúng ta cùng áp dụng vào bài Min Cost Climbing Stairs\nCho mảng cost, trong đó cost[i] là chi phí của bước thứ i trên cầu thang. Khi bạn trả phí, bạn có thể bước 1 hoặc 2 bước. Bạn được chọn bước từ vị trí 0 hoặc 1.\nTìm chi phí nhỏ nhất để đi hết cầu thang.\nBạn có thể nhận thấy rằng, khi xét bước thứ i, bạn chỉ có thể bước đến đây từ bước thứ i - 1 (bước 1 bước) hoặc từ bước thứ i - 2 (bước 2 bước). Vậy nên, chi phí nhỏ nhất khi bước đến bước thứ i sẽ bằng tổng của giá trị nhỏ hơn trong 2 bước trước đó cộng với cost[i]. Từ đó chúng ta có 2 cách giải tương ứng như sau.\nTop-Down\n1 2 3 int result = min(minCost(n-1, cost, memo), minCost(n-2, cost, memo)) + (n == cost.size() ? 0 : cost[n]); return memo[n] = result; Bottom-Up\n1 2 3 4 for (int i = 2; i \u0026lt;= n; ++i) { dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]); } return dp[n] Tìm số cách khác nhau Đề bài thường có dạng:\nCho một mục tiêu, tìm số cách khác nhau để đạt mục tiêu đó.\nHướng giải:\nTính tổng tất cả các cách có thể để đạt đến mục tiêu.\n1 routes[i] = routes[i-1] + routes[i-2] + ... + routes[i-k] Top-Down\n1 2 3 4 for (int j = 0; j \u0026lt; ways.size(); ++j) { result += topDown(target - ways[j]); } return memo[/*state parameters*/] = result; Bottom-Up\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= target; ++i) { for (int j = 0; j \u0026lt; ways.size(); ++j) { if (ways[j] \u0026lt;= i) { dp[i] += dp[i - ways[j]]; } } } return dp[target] Chúng ta cùng áp dụng vào bài Climbing Stairs\nBạn đang leo lên một chiếc cầu thang. Nó cần n bước để leo đến đỉnh. Mỗi lần bạn chỉ có thể leo 1 hoặc 2 bước.\nHãy tính bạn có bao nhiêu cách khác nhau để leo đến đỉnh?\nTương tự như bài trên, khi xét bước thứ i, bạn chỉ có thể bước đến đây từ bước thứ i - 1 (bước 1 bước) hoặc từ bước thứ i - 2 (bước 2 bước). Vậy nên, số cách khác nhau leo đến bước thứ i sẽ bằng tổng của số cách đến bước i - 1 và số cách đến bước i - 2. Từ đó chúng ta có 2 cách giải tương ứng như sau.\nTop-Down\n1 2 int result = climbStairs(n-1, memo) + climbStairs(n-2, memo); return memo[n] = result; Bottom-Up\n1 2 3 for (int stair = 2; stair \u0026lt;= n; ++stair) { dp[stair] = dp[stair-1] + dp[stair-2]; } Hợp nhất các khoảng giá trị Đề bài thường có dạng:\nCho một bộ số, tìm giải pháp tối ưu cho một bài toán mà xét số hiện tại và kết quả tốt nhất bạn có thể nhận được từ bên trái và bên phải.\nHướng giải:\nTìm tất cả giải pháp tối ưu cho mỗi khoảng và trả về kết quả tốt nhất có thể.\n1 2 // From i to j dp[i][j] = dp[i][k] + result[k] + dp[k+1][j] Top-Down\n1 2 3 4 for (int k = i; k \u0026lt;= j; ++k) { result = max(result, topDown(nums, i, k) + result[k] + topDown(nums, k+1, j)); } return memo[/*state parameters*/] = result; Bottom-Up\n1 2 3 4 5 6 7 8 9 for(int l = 1; l\u0026lt;n; l++) { for(int i = 0; i\u0026lt;n-l; i++) { int j = i+l; for(int k = i; k\u0026lt;j; k++) { dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]); } } } return dp[0][n-1]; Chúng ta cùng áp dụng vào bài Minimum Cost Tree From Leaf Values\nCho một mảng arr các số dương. Chọn tất cả cây nhị phân thoả mãn điều kiện:\nMỗi node có 0 hoặc 2 node con Giá trị các phần tử của mảng arr tương ứng với giá trị của mỗi lá (node không có con) khi duyệt cây theo in-order Giá trị của mỗi node không phải lá thì bằng tích của lá lớn nhất trong cây con trái và phải của nó Trong tất cả các cây được chọn, tìm cây có tổng các node không phải lá nhỏ nhất.\n1 2 3 4 5 6 7 8 9 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n - l; ++i) { int j = i + l; dp[i][j] = INT_MAX; for (int k = i; k \u0026lt; j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]); } } } String Đề bài cho String thường có rất nhiều dạng, nhưng hầu hết đều là cho 1 hoặc 2 string với độ dài không quá lớn.\nCho 2 string s1 và s2, trả về kết quả gì đấy.\nHướng giải:\nHầu hết các bài toán dạng này có thể giải với kết quả có độ phức tạp về thời gian là O(n).\n1 2 3 4 5 6 7 8 9 10 11 // i - indexing string s1 // j - indexing string s2 for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (s1[i-1] == s2[j-1]) { dp[i][j] = /*code*/; } else { dp[i][j] = /*code*/; } } } Nếu đề bài chỉ cho 1 string thì cách giải sẽ hơi khác một chút:\n1 2 3 4 5 6 7 8 9 10 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n-l; ++i) { int j = i + l; if (s[i] == s[j]) { dp[i][j] = /*code*/; } else { dp[i][j] = /*code*/; } } } Chúng ta cùng áp dụng vào bài Longest Common Subsequence\nCho 2 string text1 và text2, tìm chiều dài lớn nhất của subsequence chung.\nXét ký tự thứ i của text1 và ký tự thứ j của text2.\nNếu chúng giống nhau, chúng ta tăng chiều dài subsequence chung thêm 1 Nếu chúng khác nhau, chúng ta sẽ lấy chiều dài lớn hơn trong 2 trường hợp i - 1 với j hoặc i với j - 1 1 2 3 4 5 6 7 8 9 for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (text1[i-1] == text2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } Với bài toán 1 string, chúng ta sẽ áp dụng vào bài Palindromic Substrings\nCho 1 string s, tính số lượng palindromic substring của nó.\nChúng ta xét ký tự thứ i và j, nếu chúng giống nhau và substring từ i + 1 đến j - 1 đã là palindromic thì chúng ta tìm được một palindromic mới.\n1 2 3 4 5 6 7 8 9 10 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n-l; ++i) { int j = i + l; if (s[i] == s[j] \u0026amp;\u0026amp; dp[i+1][j-1] == j-i-1) { dp[i][j] = dp[i+1][j-1] + 2; } else { dp[i][j] = 0; } } } Ra quyết định Dạng bài thì nổi tiếng với loạt bài House Robber và Best Time to Buy and Sell Stock.\nĐề bài thường có dạng:\nCho một tập giá trị, tìm đáp án với tuỳ chọn là chọn hoặc bỏ qua giá trị hiện tại.\nHướng giải:\nNếu bạn quyết định chọn giá trị hiện tại, hãy sử dụng kết quả trước đó, trong đó giá trị trước đó bị bỏ qua. Ngược lại, nếu bạn quyết định bỏ qua giá trị hiện tại, hãy sử dụng giá trị trước đó, trong đó giá trị trước đó được sử dụng.\n1 2 3 4 5 6 7 8 // i - indexing a set of values // j - options to ignore j values for (int i = 1; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]}); dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]}); } } Chúng ta cùng áp dụng vào bài House Robber\nBạn là một tên trộm chuyên nghiệp đang có kế hoạch ăn trộm cả một dãy phố. Tuy nhiên dãy phố này có hệ thống an ninh liên kết với nhau, và nó sẽ tự động báo cảnh sát nếu 2 ngôi nhà cạnh nhau cùng bị trộm.\nCho một mảng nums đại diện cho số tiền trong mỗi ngôi nhà. Hãy tính số tiền tối đa bạn có thể trộm được mà không bị báo cảnh sát.\nChúng ta tạo 1 mảng 2 chiều với công thức:\ndp[i][1] là tổng số tiền nếu quyết định trộm nhà thứ i dp[i][0] là tổng số tiền nếu quyết định không trộm nhà thứ i 1 2 3 4 for (int i = 1; i \u0026lt; n; ++i) { dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]); dp[i][0] = dp[i-1][1]; } Reference https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns ","date":"2024-05-05T00:00:00+07:00","image":"https://namanh11611.github.io/p/dynamic-programming/dynamic_programming_hu8793582496082143425.jpg","permalink":"https://namanh11611.github.io/p/dynamic-programming/","title":"LeetCode: Dễ dàng nhận biết 5 dạng bài Dynamic Programming"},{"content":"Có lẽ Clean Code là một vấn đề kinh điển trong ngành lập trình, mình đã có lần nhắc đến cuốn sách Clean Code của Uncle Bob trong bài viết Những điều giá như mình biết từ khi còn là Junior. Tuy nhiên thì lần này mình sẽ không viết lại những nội dung trong đó nữa, các bạn nên đọc trực tiếp sách để có trải nghiệm tốt nhất. Mình chỉ muốn chia sẻ một vài tip mà mình hay áp dụng để giữ code luôn được gọn gàng sạch đẹp.\nDùng return để tránh if/else hell Không biết bạn đã bao giờ gặp if/else hell kiểu như này trong code chưa?\n1 2 3 4 5 6 7 8 9 10 11 void doSomething() { if (condition1) { doFirstTask() if (condition2 != null) { doSecondTask() if (condition3.isNotEmpty()) { doThirdTask() } } } } Về lý thuyết thì đoạn code trên không có vấn đề gì cả. Thế nhưng mình lại không thích nhìn kiểu code lồng nhau nhiều lớp như vậy. Vậy nên mình thường sẽ dùng return để tránh phải viết quá nhiều dấu ngoặc {} lồng nhau. Chúng ta có thể refactor lại đoạn code trên như sau:\n1 2 3 4 5 6 7 8 void doSomething() { if (!condition1) return doFirstTask() if (condition2 == null) return doSecondTask() if (condition3.isEmpty()) return doThirdTask() } Về mặt logic code thì tương đương nhau, tuy nhiên thì về mặt ý nghĩa thì hơi khác một chút. Với trường hợp ban đầu, khi đồng nghiệp đọc code, họ sẽ hiểu là \u0026ldquo;Nếu thoả mãn điều kiện này thì code sẽ xử lý tiếp như thế này\u0026rdquo;. Còn với trường hợp thứ hai, họ sẽ hiểu thành \u0026ldquo;Nếu không thoả mãn điều kiện này thì code sẽ không xử lý tiếp\u0026rdquo;. Tư duy theo cách thứ 2 đôi khi hơi ngược một chút, nên bạn cũng áp dụng tuỳ trường hợp thôi nhé, chứ đừng áp dụng máy móc cho tất cả các trường hợp.\nDùng Map hoặc Set thay cho List Map và Set là 2 cấu trúc dữ liệu đặc biệt mà chắc chắn các bạn đã được học ở đại học. Tuy nhiên, trong dự án, mọi người thường luôn luôn sử dụng List vì nó \u0026ldquo;tiện\u0026rdquo;. Với mình thì trước khi chọn loại dữ liệu cho một list, mình luôn đặt câu hỏi liệu dùng Map hay Set có giúp code ngắn gọn và tăng performance hơn không? Nếu có, chắc chắn mình sẽ ưu tiên dùng 2 loại dữ liệu này trước.\nVí dụ, mình có một biến existingValueList gồm một list các value đã tồn tại, khi user nhập một value mới, mình cần check xem nó đã tồn tại chưa, nếu có thì trả về lỗi. Nếu existingValueList có kiểu dữ liệu là List, mình sẽ cần viết hàm check như sau:\n1 boolean isExisting = existingValueList.contains(value) Nhưng nếu kiểu dữ liệu là Set, chúng ta sẽ viết như sau:\n1 boolean isExisting = existingValueSet.contains(value) \u0026ldquo;Ủa, rồi khác gì nhau?\u0026rdquo;. Đúng là cách viết thì không khác gì nhau, nhưng sự khác nhau nằm trong chính hàm contains(), run time của List sẽ là O(n), trong khi đó của Set chỉ là O(1).\n99% là bạn đã biết điều này, nhưng đôi khi bạn sẽ sử dụng List như một thói quen. Vậy nên lần sau, trước khi tạo một List, bạn hãy chậm lại một nhịp để suy nghĩ xem có nên dùng Map hay Set không nhé.\nNgoài ra chúng ta còn nhiều cấu trúc dữ liệu khác như Stack, Queue, Tree\u0026hellip; Nhưng trong dự án thực tế thì mình hiếm gặp những use-case cần áp dụng bọn này.\nĐừng comment code không dùng nữa, hay xoá nó Mình thấy một số bạn có thói quen khi sửa một tính năng gì đấy, thường sẽ comment lại code cũ thay vì xoá nó. Hoặc có những function cũ không dùng nữa, nhưng cũng chẳng buồn comment hay xoá gì, cứ để nó nằm vậy trơ gan cùng tuế nguyệt. Nhưng tin mình đi, vài tháng hoặc thậm chí vài năm sau, chắc bạn sẽ chẳng bao giờ uncomment lại đống code đấy đâu. Mỗi lần vài dòng thôi, nhưng qua năm tháng sẽ thành một núi dead code khổng lồ.\nNếu muốn xem lại code cũ, Git đã có thể giúp bạn rất tốt rồi. Vậy nên hãy mạnh dạn xoá nó, không chỉ là vài dòng code, một function, mà còn cả resource của app mà bạn không dùng nữa. Điều này sẽ giúp giảm dung lượng của source code đi nhiều.\nNếu bạn có tip nào hay ho mà đang áp dụng, hãy chia sẻ thêm với mình nhé.\n","date":"2024-05-01T00:00:00+07:00","image":"https://namanh11611.github.io/p/clean-code/tidy_hu2448421310158080315.jpg","permalink":"https://namanh11611.github.io/p/clean-code/","title":"3 cách mình áp dụng để code gọn gàng sạch đẹp hơn"},{"content":"Flutter Hooks là cái chi chi? Khi tìm kiếm từ khoá Hooks trên Google, chúng ta sẽ thấy rất nhiều kết quả liên quan đến React. Quả thật, như trong phần giới thiệu, thư viện flutter_hooks được tác giả Remi Rousselet build dựa trên niềm cảm hứng từ React.\nHooks là một loại object giúp quản lý life-cycle của Widget. Mục tiêu duy nhất của nó là giúp tăng khả năng chia sẻ source code giữa các Widget bằng cách loại bỏ các phần code trùng lặp.\nCác bạn có thể sẽ thắc mắc: \u0026ldquo;Ủa, StatefulWidget trong Flutter đã có method initState và dispose để lo việc quản lý life-cycle rồi cơ mà? Cần gì Hook nữa?\u0026rdquo;. Chính xác, thế nhưng chúng ta rất khó để tái sử dụng code trong 2 method này. Và Hooks sinh ra để giải quyết vấn đề đó.\nHướng dẫn sử dụng Một ví dụ đơn giản về Hooks như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyHookWidget extends HookWidget { const MyHookWidget({super.key}); @override Widget build(BuildContext context) { final counter = useState(0); return Scaffold( body: Center( child: Text(\u0026#39;Counter: ${counter.value}\u0026#39;), ), floatingActionButton: FloatingActionButton( onPressed: () =\u0026gt; counter.value++, child: const Icon(Icons.add), ), ); } } Bạn có thể thấy Widget của chúng ta thay vì extend StatefulWidget hay StatelessWidget, thì bây giờ nó phải extend một HookWidget. Trong method build có một từ khoá lạ lạ là useState, đấy chính là một trong những hook của Flutter Hooks, phần sau chúng ta sẽ cùng đi tìm hiểu một số hook cơ bản của nó.\nGiờ đây, khi bạn click vào FloatingActionButton, giá trị của text sẽ thay đổi với biến counter tăng dần, nó tương tự như cách mà StatefulWidget hoạt động phải không nào?\nuseEffect hook Nó gần giống với useEffect hook của React, được sử dụng để thực hiện các side effect synchronously trong quá trình render. Effect có thể return một function, function này sẽ được gọi khi effect được gọi lại hoặc widget bị dispose.\nMặc định, effect được gọi lại mỗi lần build, trừ khi chúng ta truyền param key. Khi đó, effect chỉ được gọi lại khi key thay đổi.\nSide effect có thể bao gồm stream subscription, mở một WebSocket connection hoặc thực hiện một HTTP request. Chúng ta có thể cancel chúng khi widget bị dispose.\n1 2 3 4 5 6 useEffect(() { performSideEffect(); return () { cleanUp(); }; }, [key]); useState hook Đây là loại hook cơ bản nhất khi bạn muốn chuyển một StatelessWidget sang StatefulWidget. Khi được gọi trong method build, nó sẽ giữ state giữa những lần widget rebuild.\n1 final counter = useState(0); Trong ví dụ này, chúng ta truyền cho nó một giá trị khởi tạo là 0. Biến counter chính là một instance của ValueNotifier. State được lưu trong thuộc tính value của ValueNotifier. Mỗi khi giá trị của value bị thay đổi, useState hook sẽ rebuild widget để hiển thị giá trị mới.\nuseMemoized hook Đây là một method hữu ích khi bạn cần tạo một object phức tạp và muốn trả về cùng một object đó qua nhiều lần rebuild widget con. useMemoized sẽ giúp chúng ta cache object đó, giá trị chỉ được tính toán trong lần gọi đầu tiên, còn những lần sau, nó sẽ trả về giá trị đã được lưu trước đó.\n1 2 3 4 final complexObject = useMemoized( () =\u0026gt; createComplexObject(), [] ); useRef hook Tạo một object chứa một thuộc tính có thể thay đổi. Tuy nhiên thì việc thay đổi thuộc tính của object sẽ không có effect. Nó phù hợp cho các use-case mà chúng ta cần share state giữa những lần build method được gọi, nhưng tránh được việc rebuild không cần thiết.\n1 2 3 4 5 6 7 8 9 10 11 12 final textController = useTextEditingController(); /// Sử dụng useState() trong trường hợp này /// sẽ làm widget rebuild mỗi lần nhập một ký tự // final name = useState(\u0026#39;\u0026#39;); final name = useRef(\u0026#39;\u0026#39;); useEffect(() { textController.addListener(() { name.value = textController.text; }); return null; }, []); useCallback hook Cache instance của toàn bộ một function, nếu như chính function đó được gọi lại.\n1 2 3 final cachedFun = useCallback(() { Statements }, []); useContext hook Giữ BuildContext của HookWidget, giúp chúng ta không phải truyền param context qua các method.\n1 2 3 4 5 Widget createSizedBox() { return SizedBox( height: MediaQuery.sizeOf(useContext()).height / 10 ); } useValueChanged hook Theo dõi một giá trị và trigger một callback bất cứ khi nào giá trị của nó thay đổi. Quay trở lại với ví dụ ban đầu, chúng ta sửa một chút như sau:\n1 2 3 4 5 6 7 final count = useState(0); final newCount = useState(0); useValueChanged(count.value, (oldValue, oldResult) { print(\u0026#39;oldValue = $oldValue, oldResult = $oldResult\u0026#39;); newCount.value += 5; return newCount.value; }); Khi click FloatingActionButton, kết quả sẽ được in ra lần lượt như sau:\n1 2 3 4 oldValue = 0, oldResult = null oldValue = 1, oldResult = 5 oldValue = 2, oldResult = 10 ... Bạn có thể thấy, mỗi khi giá trị của count thay đổi, newCount cũng sẽ được thay đổi theo.\nuseStream hook Giúp subscribe một Stream và return state hiện tại nó.\n1 final snapshot = useStream(backend.stream); useAnimationController hook Tạo một AnimationController và nó sẽ bị dispose một cách tự động.\n1 2 3 final controller = useAnimationController( duration: Duration(seconds: 1) ); Lợi ích của Hooks State Management: Hooks giúp đơn giản hóa việc quản lý local state, đảm bảo widget chỉ xử lý logic liên quan đến nó. Giảm duplicate code: Custom hooks cho phép bạn tái sử dụng logic của widget, giảm đáng kể việc duplicate code và cải thiện chất lượng code. Cải thiện Hot Reload: Với hooks, hot reload mặc định ít bị lỗi hơn vì trạng thái của hook được giữ nguyên. Tiện lợi: Một số built-in hooks như useAnimationController, useFuture và useStream là những method có thể áp dụng cho nhiều use-case phổ biến. Đơn giản hóa life-cycle: Việc quản lý các life-cycle phức tạp trở nên đơn giản hơn rất nhiều với Flutter Hooks. Chúng cung cấp một giải pháp để dễ dàng quản lý state, side-effects và stream subscriptions. Custom hooks linh hoạt: Ngoài các hook đã có sẵn, Flutter Hooks cho phép bạn tạo các hooks tùy chỉnh, giúp việc viết code linh hoạt hơn. Có thể bạn đã biết Remi Rousselet còn là tác giả của 2 thư viện State Management nổi tiếng là Provider và Riverpod. Trong đó thì anh ấy đã kết hợp Riverpod và Hook trong một thư viện là Hooks Riverpod. Bạn có thể nhân hai sức mạnh với thư viện này. Riverpod là dành cho \u0026ldquo;global\u0026rdquo; application state, còn hooks dành cho local widget state.\nLời kết Mình thấy Flutter Hooks khá tiềm năng, nhưng vẫn thấy chưa nhiều dự án áp dụng. Không biết các bạn đã từng áp dụng nó chưa? Nếu thấy nó có ưu hoặc nhược điểm gì, hãy chia sẻ với mình nhé.\n","date":"2024-04-30T00:00:00+07:00","image":"https://namanh11611.github.io/p/flutter-hooks/hooks_hu17193798836663589779.jpeg","permalink":"https://namanh11611.github.io/p/flutter-hooks/","title":"Flutter Hooks - viết code ngắn gọn và hiệu quả hơn"},{"content":"Chữ Quốc ngữ vốn chứa đựng nhiều lỗi Trước hết để mọi người không nhầm lẫn thì cần phân biệt rõ ràng 2 khái niệm tiếng Việt và chữ Quốc ngữ. Tiếng Việt là ngôn ngữ của người Việt và đã xuất hiện từ khoảng đầu Công nguyên, là cách mà cha ông ta nói chuyện, giao tiếp với nhau, gọi tên sự vật, hiện tượng như trời, đất, bánh chưng, bánh dày\u0026hellip; Còn chữ Quốc ngữ là một loại chữ viết dựa trên chữ cái Latinh, được sáng tạo bởi các tu sĩ Bồ Đào Nha dùng để ghi âm tiếng Việt vào đầu thế kỷ XVII.\nMình không có vấn đề gì với tiếng Việt, nhưng chữ Quốc ngữ thì mình thấy nó còn chứa đựng nhiều lỗi. Ví dụ như hồi đi học, có bao giờ bạn thắc mắc:\nTại sao tên một số địa danh như Đắk Lắk, Đắk Nông lại có cách viết khác với các từ thông thường? Tại sao chữ c, g, ng lại không thể đứng trước e, ê, i, mà chúng ta phải dùng k, gh, ngh? Tại sao Bác Hồ lại viết là Đường Kách mệnh chứ không phải là Đường Cách mạng như ngày nay chúng ta hay viết? Chữ Quốc ngữ vay mượn chủ yếu từ tiếng Bồ Đào Nha và tiếng Ý, ví dụ như trong tiếng Bồ Đào Nha, nếu để chữ c đứng trước a,o,u sẽ biểu thị phụ âm /k/, nhưng khi đứng trước e,i sẽ biểu thị phụ âm /s/. Vì vậy để tránh cho những người biết tiếng biết Bồ Đào Nha khỏi đọc sai, các tu sĩ mới đặt ra quy tắc phải dùng k thay cho c khi đứng trước e,ê,i,y.\nCòn với người Việt Nam, chúng ta không bị hiểu nhầm như trên, nên chúng ta có thể hoàn toàn dùng c thay cho k trong mọi từ mà không bị phát âm sai. Ví dụ như nếu mình viết là con ciến thay cho con kiến, cái cem thay cho cái kem, mặc dù là viết sai chính tả, nhưng người Việt vẫn có thể đọc đúng, chứ không đọc thành con siến hay cái sem như người Bồ Đào Nha.\nNhư trong tiêu đề của bài viết này, mình dùng từ kải kách thay cho cải cách nhưng các bạn vẫn hiểu ý mình đang truyền đạt đúng không?\nNhững công trình không bao giờ được triển khai Nhận thấy sự bất hợp lý này, đã có rất nhiều công trình đề xuất cải tiến chữ Quốc ngữ. Trong đó có thể kể đến dự thảo Phương án cải tiến chữ Quốc ngữ bước đầu của Giáo sư Hoàng Phê xây dựng từ những năm 1960-1961. Trong đó, ông đề xuất một số điểm như:\nBỏ h trong gh và ngh. Ví dụ: ghê -\u0026gt; gê, nghe -\u0026gt; nge, nghiêng -\u0026gt; ngiêng. Dùng f thay ph, d thay đ, z thay d và gi. Ví dụ: dân tộc -\u0026gt; zân tộc, đất nước -\u0026gt; dất nước, phương pháp -\u0026gt; fương fáp. Nhất luật viết phụ âm /k/ bằng k trong mọi trường hợp, thay cho c, và nghiên cứu thay cả cho q. Ví dụ như Đường kách mệnh. Hoặc một trường hợp nổi tiếng khác là đề xuất Phương án cải tiến chữ Quốc ngữ của Phó giáo sư Bùi Hiền. Ông từng công bố đề xuất ở Báo Giáo dục và Thời đại số 72 ngày 8/9/1995. Cuối năm 2017, sau một cuộc hội thảo thì đề xuất của ông được đưa ra truyền thông và đã có bàn cãi sôi nổi do những khác lạ trong lối viết cải tiến mà ông đưa ra. Ở thời điểm đó, khi mà người người nhà nhà chê trách PGS Bùi Hiền, có lẽ mình là một trong số ít những người thấy được một số điểm hợp lý trong đề xuất của ông (chỉ một số thôi chứ không phải toàn bộ phương án).\nNhưng qua năm tháng, các bạn có thể thấy những công trình trên sẽ không bao giờ được triển khai, bởi vì nó sẽ gây tốn kém rất lớn về thời gian, tiền bạc và nguồn lực của cả xã hội. Hãy thử tưởng tượng cả nước phải đi đổi Căn cước công dân, Sổ hộ khẩu, giấy tờ hành chính, các bộ gõ tiếng Việt phải cập nhật lại quy tắc, các phần mềm phải cập nhật lại giao diện\u0026hellip; Mình nghĩ nó phải tốn cả chục năm để hoàn thành mất.\nNhững nguyên lý trong lập trình Câu chuyện trên nghe qua thì có vẻ như chẳng liên quan đến ngành Công nghệ thông tin, nhưng các bạn hãy thử xoay góc nhìn, coi chữ Quốc ngữ như một ngôn ngữ lập trình với bộ quy tắc riêng về cách đặt phụ âm, cách kết nối các âm, cách đánh dấu thanh\u0026hellip; Qua đó, chúng ta sẽ có một số góc nhìn mới về sự ra đời và phát triển của chữ Quốc ngữ và liên hệ nó với các nguyên lý, bài học trong ngành lập trình.\nCode luôn có đầy rẫy edge case Có thể thấy, tên một số địa danh như Đắk Lắk, Đắk Nông chính là một edge case của chữ Quốc ngữ. Trong lập trình cũng vậy, chúng ta luôn phải lưu ý xử lý edge case để tránh chương trình gặp lỗi sau này.\nVí dụ như thực hiện phép chia thì luôn phải kiểm tra trường hợp số chia khác 0, tìm phần tử đầu tiên của mảng thì luôn phải kiểm tra trường hợp mảng bị rỗng.\nVí dụ bạn có một input text field thì cần suy nghĩ các edge case như user không nhập gì, user nhập text quá dài hoặc user nhập sai format mà chúng ta mong muốn. Việc check edge case trong trường hợp này còn giúp chúng ta tránh được cuộc tấn công Cross Site Scripting (XSS).\nTính tương thích ngược (Backward Compatible) Thực ra chữ Quốc ngữ vẫn đang có những sự cải tiến từ lúc ra đời đến ngày nay. Ví dụ như ngày xưa Bác Hồ viết Đường Kách mệnh nhưng ngày nay chúng ta lại viết là Đường Cách mạng. Hoặc trước đây, các từ ghép hoặc tên riêng thường có dấu gạch nối ở giữa, ví dụ như độc-lập, tự-do, Việt-Nam, Luân-Đôn\u0026hellip; Thế nhưng ngày nay, những dấu gạch nối đó đã bị bỏ đi. Những sự cải tiến nhỏ này vẫn đảm bảo mọi người có thể hiểu được cách viết mới dễ dàng, không cần tốn quá nhiều thời gian để làm quen.\nTrong các ngôn ngữ lập trình, khi có nâng cấp một version mới, thường nó sẽ luôn được đảm bảo tính tương thích ngược để những chương trình viết theo cách viết code cũ không bị xảy ra lỗi. Ví dụ như các function cũ có thể bị đánh dấu là Deprecated, hiển thị warning cho các lập trình viên biết rằng function này sẽ sớm bị thay thế, nhưng không bị xoá ngay để chúng ta có thời gian update nó.\nCode đang chạy ổn thì đừng đụng vào Việc đề xuất cải cách của PGS Bùi Hiền bị dư luận phản ứng dữ dội một phần vì nó khác quá xa với những gì mà mọi người đang đọc, đang viết hàng ngày. Nếu được áp dụng vào thực tế, chắc chắn trong quá trình thực thi sẽ có những sự xung đột giữa những văn bản, phần mềm được viết bằng kiểu chữ cũ và kiểu chữ cải cách.\nNó giống như câu chuyện kinh điển trong ngày lập trình mà anh em thường nói vui với nhau \u0026ldquo;Code đang chạy ổn thì đừng đụng vào\u0026rdquo;. Hồi mới ra trường, mình từng nhiệt tình xung phong refactor một feature có flow khá phức tạp. Thế rồi hậu quả là mình mất một mớ thời gian để đi fix bug cho những corner case của feature đó mà khi bắt đầu làm mình chưa lường trước hết được.\nPhát hiện lỗi càng muộn, chi phí sửa đổi càng lớn Như mình chia sẻ ở trên, những công trình cải cách chữ Quốc ngữ trên có thể sẽ không bao giờ được đưa vào đời sống bởi vì sự tốn kém của nó. Nếu muốn sửa, có lẽ thời điểm tốt nhất là lúc\u0026hellip; các tu sỹ Bồ Đào Nha mới sáng tạo ra nó.\nCùng là một bug, nếu bạn phát hiện ra nó ở phase develop, bạn chỉ cần sửa vài dòng code là xong. Nếu nó đã được release lên beta, việc chỉnh sửa có thể sẽ ảnh hưởng đến một nhóm nhỏ user. Còn nếu xui hơn là sản phẩm đã được release lên production tới toàn bộ user, một thay đổi nhỏ có thể gây ảnh hưởng cực lớn, ví dụ như làm mất dữ liệu của user hoặc gây ra trải nghiệm tệ trong quá trình sử dụng phần mềm.\nBạn có nhớ đến trường hợp lỗi pin của điện thoại Galaxy Note 7 không? Sự cố này đã khiến Samsung phải thu hồi dòng điện thoại này, gây thiệt hại cho hãng 5,4 tỷ USD.\nKết luận Bài viết này chỉ đưa ra một góc nhìn thú vị về lập trình và cuộc sống, không nhằm mục đích công kích tổ chức hay cá nhân nào. Hy vọng bạn coi nó như một bài viết mang tính giải trí trong lúc trà dư tửu hậu.\n","date":"2024-03-20T00:00:00+07:00","image":"https://namanh11611.github.io/p/vietnamese/vietnamese_hu14879662551756878564.jpeg","permalink":"https://namanh11611.github.io/p/vietnamese/","title":"Từ câu chuyện kải kách chữ Quốc ngữ đến những nguyên lý trong lập trình"},{"content":"Những ngày xưa cũ Anh em cũng biết rằng, diagram nói riêng và document nói chung có vai trò quan trọng trong các dự án, nó như một chiếc la bàn giúp anh em dev hiểu được ý tưởng của PM, tech lead hay BA, định hướng được flow cần làm, đồng thời là bằng chứng để anh em đối chiếu khi có tranh cãi về yêu cầu của dự án. Một bức ảnh đáng giá hơn ngàn lời nói, đôi khi một cái diagram rõ ràng sẽ giúp tiết kiệm được vài giờ đồng hồ giải thích, trao đổi qua lại.\nTrước đây, khi vẽ diagram cho dự án, mình thường dùng draw.io. Cho bạn nào chưa biết thì nó là một tool online vẽ diagram bằng cách kéo thả. Nhưng mỗi khi cần update lại diagram, mình phải kéo thả lại từng ô hay từng cái mũi tên khá mất thời gian. Cho đến một ngày mình được một người anh giới thiệu về Mermaid, mọi chuyện đã bước sang một trang mới\u0026hellip;\nĐược khai sáng về Mermaid Theo định nghĩa trên trang chủ thì Mermaid là một công cụ được xây dựng dựa trên JavaScript, giúp tạo diagram và chart một cách linh hoạt từ text có cú pháp tương tự Markdown.\nƯu điểm Đây là một công cụ mã nguồn mở và hoàn toàn miễn phí. Nó hỗ trợ nhiều loại diagram và chart phổ biến như Flowchart, Sequence diagram, Class diagram, State diagram, Git graph\u0026hellip;\nCú pháp cũng rất đơn giản và dễ học. Nếu bạn đã quen thuộc với Markdown thì chỉ cần dành chút thời gian là sẽ thông thạo. Giờ đây, mỗi khi yêu cầu của dự án thay đổi, bạn chỉ cần sửa vài dòng text thôi thì diagram sẽ được update theo một cách nhanh chóng.\nVới mục đích vẽ các diagram đơn giản, các bạn hoàn toàn có thể sử dụng Mermaid Live Editor, không cần cài đặt bất cứ thứ gì. Với các dự án của công ty, Mermaid cũng đã được tích hợp với Notion hoặc các sản phẩm của Atlassian. Còn nếu bạn muốn sử dụng ở local thì Mermaid có thể dùng ngay trên các IDE phổ biến như Visual Studio Code hoặc họ nhà JetBrains.\nSo sánh với PlantUML Trên thị trường hiện tại cũng đã có một số công cụ khác render diagram từ text như Mermaid, trong đó nổi bật nhất là PlantUML. Sau đây mình sẽ đưa ra một bảng so sánh để các bạn có cái nhìn tổng quan.\nTiêu chí Mermaid PlantUML GitHub Star (25/2/2024) 65.400 9.300 Loại diagram Flow, Sequence, Class, State, Git graph\u0026hellip; Sequence, Usecase, Class, Object, Activity, State\u0026hellip; Hỗ trợ online Có Có Hỗ trợ offline Có Có Tính phí Miễn phí Miễn phí Khác Dễ học, dễ sử dụng cho người mới Có nhiều thư viện mở rộng Cài đặt trên Visual Studio Code Hiện tại ở dự án của mình thì team đang tạo riêng một project cho các diagram, dùng Git để quản lý version và dùng Visual Studio Code để vẽ.\nBạn chỉ cần cài thêm 2 extension Markdown Preview Mermaid Support và Mermaid Markdown Syntax Highlighting trên Visual Studio Code là đủ dùng rồi.\nMỗi khi cần vẽ 1 diagram, bạn tạo 1 file với đuôi .md và viết cú pháp của Mermaid, bạn có thể click button Open Preview ở góc trên bên phải để vừa code vừa xem diagram được update trực tiếp ở bên cạnh. Và kết quả như sau:\nBạn cứ xem trước ví dụ đi đã, mình sẽ đi vào giới thiệu chi tiết cú pháp của từng loại diagram trong phần tiếp theo.\nCú pháp các diagram phổ biến Flowchart Flowchart bao gồm các node và các cạnh (có thể là đường vô hướng hoặc mũi tên có hướng). Code Mermaid sẽ xác định cách tạo các node và cạnh, các loại cạnh tuỳ chỉnh theo mục đích của người vẽ.\nCú pháp mẫu:\n1 2 3 4 5 flowchart TD A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; flowchart: keyword của loại chart này (bạn có thể dùng graph cũng tương đương). TD: hướng của chart (top to down). Ngoài ra còn có: TB: top to bottom (giống top to down) BT: bottom to top RL: right to left LR: left to right A, B, C, D: tên của các node. Ngoài hình chữ nhật mặc định, bạn cũng có thể dùng nhiều loại hình khác như hình chữ nhật bo tròn, hình thang, hình tròn\u0026hellip; --\u0026gt;: loại cạnh có hướng. Ngoài ra còn các loại vô hướng, đa hướng, có gắn text\u0026hellip; Kết quả:\nSequence diagram Sequence diagram là sơ đồ tương tác cho thấy các quy trình hoạt động với nhau như thế nào và theo thứ tự nào.\nCú pháp mẫu:\n1 2 3 4 5 6 7 8 9 10 11 12 sequenceDiagram participant Alice participant Bob participant John Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! sequenceDiagram: keyword của diagram. participant: định nghĩa các thành phần tham gia diagram theo thứ tự lần lượt. Như trong ví dụ này, chúng ta có 3 thành phần là Alice, Bob và John. Mỗi dòng lần lượt định nghĩa tin nhắn giữa các thành phần. -\u0026gt;\u0026gt;, --\u0026gt;\u0026gt;: các loại tin nhắn có hướng nét liền và nét đứt. Kết quả:\nClass diagram Class diagram trong UML (Unified Modeling Language) là một loại sơ đồ cấu trúc tĩnh mô tả cấu trúc của hệ thống bằng cách hiển thị các lớp của hệ thống, thuộc tính, hoạt động (hoặc phương thức) của chúng và mối quan hệ giữa các đối tượng.\nCú pháp mẫu:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label classDiagram: keyword của diagram. chimp, gorilla, elementData: thuộc tính của các lớp. size(), equals(): phương thức của các lớp. *--, o--: mối quan hệ của các lớp. Kết quả:\nState diagram State diagram là một loại sơ đồ để mô tả hành vi của hệ thống, nó thể hiện một số các trạng thái của hệ thống.\nCú pháp mẫu:\n1 2 3 4 5 6 7 8 stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] stateDiagram: keyword của diagram. [*]: điểm bắt đầu hoặc kết thúc. Still, Moving, Crash: các trạng thái của hệ thống. --\u0026gt;: các bước chuyển đổi trạng thái. Kết quả:\nGit graph Git graph là minh hoạ của git commits và git actions (commands) trên các branch khác nhau.\nCú pháp mẫu:\n1 2 3 4 5 6 7 8 9 10 gitGraph commit commit branch develop commit commit commit checkout main commit commit gitGraph: keyword của graph. commit: tạo một commit mới trên branch hiện tại. branch: tạo và chuyển sang một branch mới, set nó thành current branch. checkout: checkout về một branch đã tồn tại và set nó thành current branch. merge: merge một branch vào current branch. Kết quả:\nKết luận Mermaid thực sự rất mạnh mẽ và linh hoạt, nó cung cấp cho chúng ta nhiều option để vẽ các loại diagram. Tuy nhiên trong bài viết ngắn này, mình chưa thể giới thiệu hết với anh em các option đó. Nếu mọi người cần chi tiết hơn, có thể tham khảo document của Mermaid mình đính kèm ở từng phần title. Hy vọng các bạn đã có cái nhìn tổng quan về Mermaid và có thể áp dụng nó vào trong các dự án của mình hoặc của team, giúp anh em tiết kiệm thời gian và công sức.\n","date":"2024-02-25T00:00:00+07:00","image":"https://namanh11611.github.io/p/mermaid/mermaid_hu16930185805872469308.png","permalink":"https://namanh11611.github.io/p/mermaid/","title":"Mermaid - Vẽ diagram và chart dễ như ăn kẹo bằng Markdown"},{"content":"Vấn đề Gần đây mình có tham gia luyện LeetCode để tìm niềm vui sau những giờ làm việc căng thẳng. Thỉnh thoảng mình gặp một vài bài cần phải áp dụng Binary Search để giải. Dành cho anh em nào chưa biết thì:\nBinary Search là thuật toán tìm kiếm một giá trị target trong mảng đã được sắp xếp. Nó sẽ so sánh target với phần tử chính giữa của mảng (middle), nếu target != middle thì sẽ tiếp tục tìm kiếm trong một nửa mảng có giá trị nhỏ hơn hoặc lớn hơn middle, tuỳ theo điều kiện bài toán. Quá trình này được lặp lại cho đến khi tìm được vị trí của phần tử bằng với target.\nSau mỗi bước tìm kiếm, số lượng phần tử sẽ giảm đi một nửa. Vậy nên độ phức tạp của thuật toán này là O(log n).\nTuy nhiên, khi áp dụng thuật toán này thì mình gặp một số câu hỏi cần trả lời là:\nKhi nào nên dừng vòng lặp? Khi left \u0026lt; right hay left \u0026lt;= right? (left và right là 2 giá trị biên của mảng sau mỗi vòng lặp) Nên update các giá trị biên như thế nào? Dùng left = mid hay left = mid + 1? Dùng right = mid hay right = mid + 1? Nhìn có vẻ đơn giản nhưng việc chọn sai công thức có thể dẫn đến kết quả sai, rồi mình lại phải sửa đi sửa lại rất mất thời gian.\nCho đến một ngày, mình tìm được một công thức thần thánh\u0026hellip;\nTemplate đơn giản Ta\u0026hellip; da\u0026hellip; Tác giả chia sẻ chi tiết về template rất đơn giản nhưng thần thánh ở bài viết này.\nTheo đó, giả sử chúng ta có một search space, nó có thể là một mảng hoặc một khoảng giá trị, thường sẽ được sắp xếp theo thứ tự tăng dần. Nhiệm vụ của chúng ta là tìm giá trị num nhỏ nhất sao cho hàm condition(num) trả về giá trị true.\nTemplate của chúng ta như sau (mình sẽ viết bằng code Java cho đa số mọi người dễ đọc nhé):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int binarySearch() { // Bạn tự định nghĩa giá trị khởi tạo của 2 biên int left = min(searchSpace), right = max(searchSpace); while (left \u0026lt; right) { // Viết như thế này để tránh tràn số int mid = left + (right - left) / 2; if (condition(mid)) { right = mid; } else { left = mid + 1; } } // Có thể là left hoặc left - 1 tuỳ yêu cầu bài toán return left; } boolean condition(int num) { // Code check condition } Bạn có thể áp dụng template này vào tất cả các bài binary search, khi đó bạn cần thực hiện 3 việc:\nTìm giá trị left và right phù hợp. Bạn cần chắc chắn rằng 2 giá trị biên này đã bao gồm tất cả các giá trị có thể là kết quả của bài toán. Định nghĩa hàm condition chính xác. Đây thường là phần khó nhất trong các bài binary search phức tạp. Chọn giá trị trả về là left hay left - 1. Nhớ rằng khi kết thúc vòng lặp while, left là index của phần tử nhỏ nhất thoả mãn hàm condition trả về true. Hãy tưởng tượng, chúng ta có dãy số với index từ 0 đến n như sau:\n1 2 Index: 0, 1, ... left - 1, left, ... n - 1, n Condition return: False, False, ... False, True, True, True Vậy nếu bài toán yêu cầu tìm giá trị nhỏ nhất thoả mãn condition return true thì bạn return left, còn nếu yêu cầu tìm giá trị lớn nhất thoả mãn condition return false thì bạn return left - 1.\nÁp dụng vào problem đơn giản Bắt đầu với bài toán tìm căn bậc 2 của số X: Sqrt(x)\nCho một số nguyên không âm x, tìm căn bậc 2 của x, làm tròn xuống số nguyên không âm gần x nhất.\nĐiều kiện: $0 \u0026lt;= x \u0026lt;= 2^{31} - 1$\nVí dụ 1:\n1 2 Input: 4 Output: 2 Ví dụ 2:\n1 2 Input: 8 Output: 2 Chúng ta dễ dàng nhận thấy rằng hàm condition có thể viết như sau:\n1 2 3 boolean condition(int num) { return x / num \u0026lt; num; } Và khi kết thúc vòng lặp while, giá trị cần tìm của chúng ta sẽ là left - 1.\nNhư vậy, đáp án của chúng ta như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int mySqrt(int x) { if (x \u0026lt; 2) return x; int left = 0; int right = x; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (x / mid \u0026lt; mid) { right = mid; } else { left = mid + 1; } } return left - 1; } Áp dụng vào problem phức tạp Chúng ta cùng tìm hiểu bài toán sau: Capacity To Ship Packages Within D Days\nMột băng chuyền gồm các gói hàng phải giao từ cổng này tới cổng khác trong vòng D ngày. Gói hàng thứ i có khối lượng là weights[i]. Mỗi ngày, chúng ta chất các gói hàng lên một khay hàng trên băng chuyền theo thứ tự lần lượt được cho bởi mảng weights. Chúng ta không thể chất quá tải trọng của khay hàng.\nTìm tải trọng nhỏ nhất có thể của khay hàng để đảm bảo tất cả các gói hàng được giao trong vòng D ngày.\nĐiều kiện:\n$1 \u0026lt;= D \u0026lt;= weights.length \u0026lt;= 5 * 10^4$\n$1 \u0026lt;= weights[i] \u0026lt;= 500$\nTrước tiên, chúng ta cùng phân tích một chút. Với các bài toán đơn giản như ví dụ trước thì đọc xong đề là chúng ta biết ngay cần phải giải bằng Binary Search rồi. Nhưng đôi khi chúng ta gặp những bài toán phức tạp hơn mà mình còn không biết là cần phải áp dụng Binary Search để giải. Thế là chúng ta đi áp dụng các phương pháp khác như DFS, BFS hay Quy hoạch động để giải, nhưng càng làm càng thấy bí. Như trong bài toán này, ý nghĩ thoáng qua trong đầu mình lúc mới đọc xong đề bài là áp dụng Quy hoạch động.\nVậy dấu hiệu để nhận biết một bài toán có thể giải bằng Binary Search là khi:\nChúng ta nhận thấy đáp án của bài toán có tính đơn điệu, nghĩa là khi condition(k) return true thì condition(k + 1) cũng sẽ return true.\nQuay trở lại với bài toán trên, chúng ta thấy rằng nếu có thể giao toàn bộ các gói hàng trong D ngày với khay hàng có tải trọng M, thì khi chúng ta sử dụng khay hàng có tải trọng lớn hơn M (ví dụ M + 1) thì hoàn toàn vẫn có thể giao trong tối đa D ngày.\nVới hàm condition, chúng ta sẽ sử dụng thuật toán tham lam, tham số là tải trọng của khay hàng được cho trước. Mỗi ngày chúng ta đặt lần lượt các gói hàng lên khay đến khi hết tải trọng, từ đó tính ra tổng số ngày cần thiết để giao toàn bộ hàng, sau đó chúng ta so sánh nó với D, nếu ít hơn hoặc bằng D ngày thì return true, vượt quá thì return false.\nVới hai giá trị biên, tải trọng tối thiểu của khay hàng bằng với khối lượng của gói hàng lớn nhất, để đảm bảo chúng ta có thể giao toàn bộ các gói hàng; còn tải trọng tối đa sẽ bằng tổng khối lượng của toàn bộ hàng, khi đó chúng ta chỉ mất 1 ngày để giao hàng.\nVà đáp án của chúng ta là:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public int shipWithinDays(int[] weights, int days) { int left = 0; int right = 0; for (int w : weights) { left = Math.max(left, w); right += w; } while (left \u0026lt; maxCap) { int mid = left + (right - left) / 2; if (isValidTime(weights, days, mid)) { right = mid; } else { left = mid + 1; } } return left; } private boolean isValidTime(int[] weights, int days, int capacity) { int totalDay = 1; int curCap = 0; for (int w : weights) { curCap += w; if (curCap \u0026gt; capacity) { totalDay++; curCap = w; } } return totalDay \u0026lt;= days; } Kết luận Hy vọng qua bài viết này, các bạn có thêm tự tin chinh chiến trên đấu trường LeetCode. Kể cả khi gặp các bài khó, chỉ cần bạn nhận ra rằng bài này có thể áp dụng Binary Search, thì có thể copy paste template này vào, sau đó là để đôi bàn tay lướt nhẹ trên bàn phím. Mọi việc còn lại thật quá dễ dàng!\n","date":"2024-02-17T00:00:00+07:00","image":"https://namanh11611.github.io/p/binary-search/binary_search_hu13956952495509419990.jpeg","permalink":"https://namanh11611.github.io/p/binary-search/","title":"LeetCode: Binary Search template chinh phục mọi problem"},{"content":"Bộ nhớ Stack với Heap là cái chi chi? Quản lý bộ nhớ là một yếu tố quan trọng trong lập trình, biết cách tối ưu bộ nhớ sẽ giúp ứng dụng của chúng ta hoạt động mượt mà, không bị lag hoặc crash. JVM (Java Virtual Machine) chia bộ nhớ ra thành 2 phần: Stack và Heap (các bạn đừng nhầm với cấu trúc dữ liệu Stack và Heap nhé). Trong bài viết này, chúng ta sẽ tìm hiểu về vai trò, chức năng và cách hoạt động của từng loại bộ nhớ.\nBộ nhớ Stack Cách hoạt động Stack lưu trữ các biến có kiểu dữ liệu primitive (int, float, char, boolean\u0026hellip;), biến cục bộ và thông tin về các method được gọi. Nó hoạt động theo cơ chế LIFO (Last In First Out). Nghĩa là những method nào được gọi sau sẽ được Stack cấp phát cho một frame, chứa thông tin về tham số, biến cục bộ, và Stack sẽ giải phóng frame đó khi method được return.\nVí dụ với một đoạn code như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { doSomething(); } private static void doSomething() { long id = 123456789L; doSomethingElse(); } private static void doSomethingElse() { int age = 23; } Trong Stack sẽ lưu các thông tin theo cấu trúc sau:\nStack được dùng để thực thi một thread, chính vì vậy JVM sẽ tạo một stack riêng biệt cho mỗi thread. Mặc định, nếu chúng ta không khai báo kích thước của Stack, JVM sẽ tạo với kích thước tuỳ thuộc vào hệ điều hành và kiến trúc máy tính (thông thường là 1MB). Tuy nhiên, chúng ta có thể dùng flag -Xss để tuỳ chỉnh kích thước của Stack (không vượt quá max size, thường là 1GB).\n1 2 3 java -Xss1048576 // 1.048.576 byte java -Xss1024k // 1.024 KB java -Xss1m // 1 MB StackOverflow Một lỗi kinh điển liên quan đến Stack là StackOverflow. Nó xảy ra khi lượng data được lưu vào Stack vượt quá giới hạn của nó.\nVí dụ khi chúng ta gọi đệ quy nhưng không có điều kiện dừng:\n1 2 3 void callRecursion() { callRecursion(); } Bạn có thể tưởng tượng các method liên tục được nạp vào Stack, đến một lúc nào đó nó sẽ vượt quá kích thước 1MB nhỏ bé kia. Vì vậy, đoạn code trên sẽ ném ra lỗi java.lang.StackOverflowError.\nMột số cách để tránh StackOverflow error:\nĐảm bảo các hàm đệ quy có điều kiện dừng hoặc không bị gọi quá nhiều lần Quản lý các thread cẩn trọng Tránh sử dụng biến local có kích thước quá lớn Tránh dependencies vòng tròn Bộ nhớ Heap Cách hoạt động Heap lưu trữ các biến có kiểu dữ liệu Object hoặc array. Nó sử dụng cơ chế cấp phát và giải phóng bộ nhớ động. Heap khá linh hoạt, có thể mở rộng hoặc thu hẹp theo nhu cầu trong quá trình thực thi chương trình.\nVí dụ, khi chúng ta sử dụng từ khoá new để tạo một object Student:\n1 2 3 4 5 6 7 8 9 10 private static void doSomething() { long id = 123456789L; Student student = new Student(); doSomethingElse(); } private static void doSomethingElse() { int age = 23; String str = \u0026#34;Hello World\u0026#34;; } Bộ nhớ sẽ tìm một vùng nhớ trống ngẫu nhiên trong Heap để cấp phát và lưu thông tin của object student. Ở bên Stack sẽ có một biến tham chiếu, trỏ sang thông tin của object student bên Heap. Còn đối với String, Heap có một cấu trúc dữ liệu đặc biệt là String pool để lưu trữ chúng.\nHeap được tạo ra khi JVM khởi chạy và nó được sử dụng miễn là ứng dụng còn chạy. Khác với Stack, Heap được chia sẻ giữa toàn bộ các thread.\nMặc định, kích thước khi khởi tạo của Heap là 256MB và kích thước lớn nhất là 4068MB. Chúng ta cũng có thể thay đổi thông số này bằng flag -Xms (kích thước khởi tạo) và -Xmx (kích thước lớn nhất).\n1 2 // Initial heap size = 512MB, Maximum heap size = 1024MB java -Xms512m -Xmx1024m Garbage Collection Trong Java, Garbage Collection có trách nhiệm thu hồi bộ nhớ từ các biến trong bộ nhớ Heap mà không còn được tham chiếu đến nữa. Quá trình này được thực hiện một cách tự động. Trong ví dụ trên, khi chúng ta không còn dùng đến object student nữa, Garbage Collection sẽ tự động thu hồi vùng nhớ đã cấp phát trước đó cho nó.\nChính nhờ cơ chế này, Heap cho phép cấp phát và giải phóng vùng nhớ với các biến có kích thước lớn và cấu trúc phức tạp ở runtime. Nếu chúng ta tạo ra quá nhiều biến trong Heap nhưng code lởm nên làm cho Garbage Collection không thể thu hồi vùng nhớ hiệu quả sẽ gây ra memory leak.\nGarbage Collection hoạt động như một bạn quản lý trong nhà hàng. Khi có khách đến, các bạn nhân viên sẽ mời khách ngồi vào một bàn trống, mang bát đũa, menu ra cho khách (cấp phát bộ nhớ). Bạn quản lý sẽ thường xuyên đi vòng vòng kiểm tra, nếu thấy bàn nào khách đã ăn xong đi về thì sẽ gọi nhân viên ra lau dọn sạch sẽ để sẵn sàng đón khách mới (giải phóng bộ nhớ).\nOutOfMemory Khi Heap bị đầy và chúng ta không thể cấp phát bộ nhớ cho object mới, nó sẽ ném ra lỗi java.lang.OutOfMemoryError.\nGiải pháp của chúng ta là phân tích code, dùng các công cụ profiling để phát hiện xem memory leak xảy ra ở đâu, xoá tham chiếu tới object khi không cần dùng đến nó nữa và để cho Garbage Collection làm việc của nó. Một số cách tối ưu bộ nhớ:\nTránh tạo các object không cần thiết Tái sử dụng object nếu có thể Chọn cấu trúc dữ liệu phù hợp Ưu tiên sử dụng biến cục bộ thay vì biến toàn cục So sánh Bộ nhớ Stack Bộ nhớ Heap Lưu trữ primitive, biến cục bộ, method Object, array Tốc độ truy cập Nhanh Chậm Kích thước Nhỏ, Cố định Lớn, Linh động Phạm vi sử dụng Thread tương ứng với Stack Toàn bộ các thread Thứ tự cấp phát LIFO Ngẫu nhiên Thời gian tồn tại của biến Từ lúc call method đến lúc return Từ lúc tạo đến lúc bị Garbage Collection giải phóng Kết luận Trong bài viết này, còn nhiều khái niệm liên quan đến bộ nhớ nhưng mình chưa thể truyền tải hết. Hy vọng bạn đã hiểu một cách căn bản về cách bộ nhớ Stack và Heap hoạt động, từ đó có thêm kinh nghiệm tối ưu hiệu năng của ứng dụng.\n","date":"2024-01-04T00:00:00+07:00","image":"https://namanh11611.github.io/p/stack-heap/stack-heap_hu5938018964747300276.jpeg","permalink":"https://namanh11611.github.io/p/stack-heap/","title":"Bộ nhớ Stack và Heap trong Java"},{"content":"What is Pomodoro? Recently, my work has shifted a bit, and I find myself in an average of 4 meetings every day. Consequently, I often end up accomplishing very little throughout the day. So, I sought a time management method called Pomodoro to help me focus better on my tasks. It wasn\u0026rsquo;t until I applied it that I realized the actual coding time in a day is not as much as I thought.\nPomodoro is an Italian word, meaning tomato, because when Francesco Cirillo developed this method in the late 1980s, he used a tomato-shaped kitchen timer. In brief, this method consists of several steps:\nSet the tasks to be done. Set a timer for 25 minutes (this time is called a pomodoro). Work on the task. Finish the task and take a 5-minute break. After 4 pomodoros, take a 15-minute break. To apply Pomodoro, there are many apps, extensions, or even web applications available for you to use. You can find the one that suits you best. Personally, I am using the Focus To-Do app on the App Store, which is quite sufficient for my basic needs.\nNow, after applying it for 6 tháng, I want to share with you the benefits it brings, as well as the points I think it may not be suitable.\nImproving Focus Previously, there were days when I was extremely focused for 4-5 consecutive hours, which helped me accomplish a lot of tasks. However, after such days, I often felt quite tired.\nBut there were also days when I spent the whole hour reading news, scrolling through Facebook, and suddenly realized I hadn\u0026rsquo;t accomplished anything.\nThe human brain is truly effective when concentrated for a short period with reasonable breaks. Applying Pomodoro, knowing I only need to focus for 25 minutes, a not too long duration, allows me to fully concentrate on the task without worrying about getting tired at the end of the day. I also know that after these 25 minutes, I will have a break, so there\u0026rsquo;s no temptation to turn to Facebook during work.\nDuring one pomodoro, you should only focus on one task. For example, if you are working on task A, only work on task A. If you finish it before the pomodoro ends, spend the remaining time checking it again, but don\u0026rsquo;t jump to task B.\nImproving Health When it\u0026rsquo;s time for a 5-minute break, instead of continuing to stare at the computer, I usually take the time to go to the restroom, get more water, change my playlist, or simply stand up and move around. This helps relax my body, avoiding health issues from sitting for too long.\nHowever, I find the 5-minute duration a bit short; sometimes, I haven\u0026rsquo;t done anything, and it\u0026rsquo;s already over in 5 minutes. Therefore, in the future, I may consider adjusting it to 7 or 8 minutes and see how it goes.\nIgnoring the World According to the rule, during the 25-minute focused period, you should turn off all app notifications to avoid distraction. However, I haven\u0026rsquo;t reached the point of being able to ignore the whole world because I still need to receive chat notifications to respond to customers and colleagues promptly.\nHowever, this often disrupts my Pomodoro because I have to spend additional time checking code or documents to be able to respond to people.\nConclusion This method may be suitable for me but may not necessarily be suitable for you. Adhering to Pomodoro has helped me increase work efficiency, but sometimes it makes me feel like I\u0026rsquo;m working like a machine. Try applying it and see the results it brings for you.\n","date":"2023-12-23T00:00:00+07:00","image":"https://namanh11611.github.io/p/pomodoro/pomodoro_hu7321307280674272216.jpeg","permalink":"https://namanh11611.github.io/p/pomodoro/","title":"6-Month Journey Applying the Pomodoro Technique"},{"content":"Ngoài việc học qua các tutorial, video thì technical blog là một nguồn khá hay ho. Khi đọc blog của kỹ sư phần mềm ở các công ty lớn, bạn sẽ biết được cách họ xử lý những bài toán mà họ đã đối mặt như thế nào. Với thời đại AI phát triển, Copilot hay Tabnine đã sẵn sàng generate code để support bạn tận răng, thì các kỹ sư không còn hơn kém nhau ở khả năng nhớ syntax của ngôn ngữ này hay framework nọ nữa, mà là hơn nhau ở cách giải quyết vấn đề. Vậy thì qua bài viết này, mình sẽ giới thiệu cho bạn blog của các công ty lớn, hy vọng bạn sẽ có thêm những góc nhìn thú vị.\nBạn có thể click vào title của từng mục để chuyển đến blog.\nMeta Meta (hay còn được biết đến với tên gọi cũ là Facebook) có nhiều sản phẩm như Facebook, Instagram, Whatsapp\u0026hellip; Trong blog này, họ chia sẻ về đủ các lĩnh vực, từ Android, iOS, Web đến các chủ đề khó như VR/AR hay AI.\nGoogle Khi vào trang chủ này, bạn có thể chọn 1 trong 4 lĩnh vực mà bạn quan tâm: Mobile, Web, AI hoặc Cloud, từ đó Google sẽ giới thiệu cho bạn các bài viết chi tiết về lĩnh vực đó.\nGoogle cũng tạo nhiều khoá học về các công nghệ của họ. Mỗi khoá học bao gồm video, các bài viết giải thích chi tiết và bài tập ví dụ để bạn có thể làm theo. Khi hoàn thành, bạn có thể nhận một badge nhỏ. Khá thú vị!\nNetflix Chắc trong những năm gần đây, không còn ai xa lạ với Netflix, một nền tảng trình chiếu các bộ phim hay TV show nổi tiếng. Vậy thì thay vì dành thời gian Netflix and chill, bạn thử đọc blog của họ để xem cách họ đã build hệ thống phục vụ hàng triệu người dùng xem sao.\nDropbox Tương tự như Google Drive, Dropbox là một dịch vụ lưu trữ đám mây, giúp bạn lưu trữ file online và đồng bộ giữa các thiết bị.\nQua blog của họ, bạn sẽ học được cách tối ưu bộ nhớ, băng thông khi chia sẻ file.\nTwitter \u0026ldquo;Design a system like Twitter\u0026rdquo; có lẽ là một bài toán kinh điển khi bạn đi phỏng vấn đến vòng System Design. Vậy thì blog của Twitter sẽ là một nguồn tham khảo hữu ích cho bạn khi chuẩn bị phỏng vấn. Bạn có thể xem cách bạn nghĩ và cách Twitter thực sự làm có giống nhau không.\nGần đây, sau khi được Elon Musk mua về, Twitter thậm chí còn open source luôn cả Recommendation Algorithm của họ.\nUber Mặc dù đã rút khỏi thị trường Việt Nam sau thương vụ bắt tay với Grab, nhưng có thể nói, Uber vẫn là công ty taxi lớn nhất thế giới. Vậy nên, blog của họ sẽ rất phù hợp với những anh em đang làm trong các công ty có lĩnh vực hoạt động tương tự ở Việt Nam.\nSpotify Mình còn nhớ khi Spotify mới ra mắt ở Việt Nam, anh em đều rất ngạc nhiên với khả năng recommend của nó.\nRecommender system của Spotify là một hệ thống phức tạp, bao gồm nhiều thuật toán và Machine Learning model kết hợp. Vậy thì qua blog này, hy vọng bạn sẽ khám khá ra một phần hệ thống đó.\nLINE LINE là một trong những công ty cũ của mình. Tuy không phải là công ty top tier như những công ty trên nhưng văn hoá sharing cũng phát triển rất mạnh. Vậy nên qua bài viết này, mình muốn giới thiệu đến các bạn technical blog của các kỹ sư ở LINE.\nReference https://amitshekhar.me/blog/top-tech-engineering-blogs-of-companies ","date":"2023-05-24T00:42:00+07:00","image":"https://namanh11611.github.io/p/technical-blog/blog_hu4636568157256953931.jpeg","permalink":"https://namanh11611.github.io/p/technical-blog/","title":"Technical Blog của Engineers các công ty lớn"},{"content":"Who am I? Chào các bạn!\nMình là Nam Anh, Android developer với 5 năm kinh nghiệm. Trong 5 năm sự nghiệp ấy, mình đã kịp lang thang qua cũng kha khá công ty công nghệ ở Hà Nội này.\nĐây có lẽ là lần đầu tiên mình viết một bài mang đậm góc nhìn cá nhân. Vậy nên có thể sẽ có bạn thắc mắc: \u0026ldquo;Ông này là ai mà lên bài dạy đời vậy ta?\u0026rdquo;.\nẤy chết, mình không dạy đời ai đâu, mình chỉ chia sẻ lại những điều mà mình thấy đúng với mình. Có thể với các bạn, nó đúng hoặc sai. Nhưng biết đâu, các bạn Junior sẽ có thêm một góc nhìn để cải thiện career path của mình.\nNhững điều may mắn Có những chuyện, lúc nó xảy ra thì mình không nghĩ là nó đúng đắn, chỉ đến khi sau này ngồi nhìn lại, mình mới chợt nhận ra: \u0026ldquo;Ồ, hoá ra hồi đó mình đã làm đúng\u0026rdquo;. Và mình cảm thấy đó thực sự là những may mắn mà mình có được.\nĐọc cuốn Clean Code ngay khi vừa ra trường Phải thú nhận là hồi trước mình khá thích đọc sách và đọc cũng khá nhiều, đủ thể loại. Nhưng sách về công nghệ thì mình lại đọc ít, chắc do khả năng tiếng Anh hạn chế 😢😢\nCơ mà cuốn sách công nghệ mình tâm đắc nhất là Clean Code. Như tên gọi, cuốn sách hướng dẫn bạn cách để viết \u0026ldquo;code sạch\u0026rdquo;, một cuốn sách cực kỳ căn bản và được rất nhiều người recommend. Không hiểu ai xui mà mình đọc cuốn này ngay khi vừa mới ra trường, vừa đọc vừa note lại tóm tắt nội dung cuốn sách. Đến bây giờ mình vẫn giữ cái note đó. Học hỏi từ cuốn sách, cộng thêm cái bệnh OCD, mình nghĩ là mình cũng đã áp dụng được ít nhiều vào trong các project mà mình tham gia.\nCó người khuyên rằng Clean Code nên đọc một lần lúc mới ra trường, và một lần lúc đã đi làm được vài năm, thì khi đó mới ngấm được hết nội dung cuốn sách. Vậy nên mình cực kỳ cực kỳ khuyến khích mọi người đọc, không phân biệt bạn mới chỉ là junior hay đã là senior dày dặn kinh nghiệm.\nLàm ở những công ty product có quy trình nghiêm ngặt Về so sánh giữa công ty product và outsourcing đã có rất nhiều bài viết rồi nên mình không nhắc lại nữa. Mình đã từng làm ở cả 2 loại hình công ty. Ở trong bài viết này mình chỉ nhắc đến khía cạnh quy trình review code và mindset product.\nTheo cảm nhận cá nhân của mình thì các công ty product lớn có nhiều thời gian hơn để review code chặt chẽ, không bị ép deadline như công ty outsourcing. Mình chỉ chia sẻ công ty product lớn, bởi vì mình cũng đã làm ở các công ty product nhỏ như kiểu start-up mới thành lập, thực sự thì lúc đó chỉ mong code chạy được đã, clean hay dirty tính sau.\nNhững kiến thức mình học từ cuốn sách Clean Code thì cũng vẫn chỉ là lý thuyết suông, đến khi tham gia vào các công ty product lớn, được các anh senior review kỹ càng code cho, thì khi đó mình mới thực sự trưởng thành hơn trong từng dòng code viết ra.\nThêm một điều nữa mình học được là mindset của người làm product, kiểu lúc nào cũng nghĩ đến product, mong cho product mình tốt hơn và có nhiều user hơn. Khi mình có idea gì về feature thì cũng sẵn sàng đề xuất, góp ý với anh leader hoặc Product Manager. Cái cảm giác mà mỗi lần bạn hoàn thành xong 1 feature mà thấy nhiều user để lại comment trên App Store hay Play Store khen ngợi feature ấy, nó phê lắm 😍😍\nMạnh dạn thoát ra khỏi vùng an toàn Trong 5 năm, mình đã nhiều lần nhảy việc như bao anh em khác. Không biết các bạn thế nào chứ mình sợ cái cảm giác làm mãi ở một công ty, rồi cứ làm quen tay một công việc, đến khi muốn chuyển việc thì không bắt kịp với nhu cầu về kiến thức và kinh nghiệm của thị trường.\nVậy nên nhảy việc qua nhiều công ty giúp mình có khả năng thích ứng với nhiều loại dự án, giúp mình biết được thị trường cần gì, và đương nhiên là giúp mình có một mức thu nhập tốt hơn nữa.\nNhững điều giá như mình biết sớm hơn Nên gắn bó với một công ty đủ lâu Trái ngược với chia sẻ ở trên, trong phần này mình lại muốn khuyên bạn trẻ nên gắn bó đủ lâu với một công ty. Theo ý của mình là tối thiểu 1-2 năm. Nó giúp các bạn đủ thời gian để hiểu về project và được ghi nhận xứng đáng.\nThường khi bắt đầu tham gia vào một dự án, bạn mất vài tháng để hiểu về dự án. Thậm chí với các project phức tạp, thời gian có thể tính bằng năm. Hiểu ở đây không chỉ là hiểu về các công nghệ đang sử dụng trong source code, mà còn là hiểu về business domain, cách cái app của mình kiếm tiền, hay thậm chí là lợi thế cạnh tranh của mình so với các app khác. Có những anh senior, dù nhảy công ty nhưng họ chỉ chuyên làm các công ty về banking hoặc fintech chẳng hạn. Vậy nên ngoài kỹ năng về technical, họ còn được đánh giá cao hơn các ứng viên khác về sự am hiểu business domain.\nCác công ty hay trao giải Best employee vào Year End Party, để được các sếp ghi nhận, rõ ràng là bạn cũng phải gắn bó với công ty đủ lâu, để có thể tạo ảnh hưởng đủ lớn. Sẽ rất hiếm khi có chuyện công ty trao giải cho một ông dev vừa hết 2 tháng thử việc được, trừ khi bạn là một siêu nhân. Việc đạt được những thành tích như này sẽ chứng minh năng lực của bạn và khiến profile của bạn lung linh hơn.\nCó những lần mình chỉ làm công ty vài tháng rồi nghỉ, điều này khiến mình cảm thấy hơi lãng phí quãng thời gian đó.\nHọc English nghiêm túc sớm hơn Chắc không cần nói thì anh em ai cũng biết mức độ quan trọng của English với công việc của dev. Khi bạn có khả năng giao tiếp thành thạo English, bạn có nhiều lựa chọn hơn, làm cho các công ty nước ngoài ở Việt Nam, ngồi ở nhà làm remote, hoặc thậm chí là ra nước ngoài làm việc. Và mức thu nhập của một bạn dev với khả năng giao tiếp English tốt chắc chắn là hơn nhiều một bạn dev chỉ có khả năng đọc hiểu.\nMình ra trường với tấm bằng TOEIC 460 giắt lưng, cũng chỉ đủ để đọc hiểu cơ bản. Vài năm gần đây, mình mới học English một cách nghiêm túc, hiện tại thì mình có thể giao tiếp ổn với đồng nghiệp nước ngoài. Việc này đã mang đến cho mình rất nhiều cơ hội mới.\nMình thề là post này không phải để quảng cáo cho app Elsa, nhưng mà nó tốt thật nên mình giới thiệu cho mọi người. Khoe một chút thành tích học liên tục 88 ngày của mình (đợt trước quên học một hôm cái bị đứt streak luôn 🥲).\nKhả năng English của mình chưa tốt lắm, nên mình vẫn đang học hỏi từng ngày. Mình cũng đã học qua một số app, từ Doulingo, Memrise, Cake\u0026hellip; và hiện tại vẫn học song song Elsa với các app khác. Nhưng mình thấy Elsa là giúp mình cải thiện nhiều nhất.\nSự khác biệt đến sau 8h tối Có 2 bạn dev A và B cùng làm việc ở một công ty từ 8h sáng đến 6h chiều. Vậy thì điều gì sẽ tạo nên sự khác biệt giữa 2 bạn?\nNó đến sau 8h tối. Bạn A dành thời gian đó để học hỏi công nghệ mới, làm pet project, contribute open source project. Còn bạn B dành thời gian để chơi game, nhậu nhẹt. Có thể vài năm đầu, sự khác biệt là chưa rõ, nhưng 3 năm, 5 năm sau, khoảng cách về kiến thức, trình độ của 2 bạn sẽ trở nên rất lớn.\nCông việc ở công ty đôi khi khá dễ, vậy nên bạn chỉ có thể tìm hiểu những kiến thức khó hơn hoặc học hỏi những công nghệ mới vào thời gian rảnh của mình. Ví dụ, công việc ở công ty chỉ đơn thuần là cắt ghép UI, nó sẽ không yêu cầu bạn hiểu sâu về hệ thống, về memory. Nếu bạn không dành thời gian tự tìm hiểu thì làm sao bạn có thể tạo nên sự khác biệt so với những đồng nghiệp khác?\nTrong những năm đầu ra trường, mình cũng dành thời gian đi nhậu nhẹt khá nhiều. Không thể phủ nhận tầm quan trọng của việc gây dựng các mối quan hệ thông qua các bữa nhậu. Nhưng nếu được chọn lại, có lẽ mình sẽ muốn dành nhiều thời gian hơn để ngồi ở nhà học hỏi.\nLời kết Thực ra trong quãng đường mình đã đi qua, có những lần mình đưa ra quyết định đúng, nhưng cũng đầy những lần mình chọn lựa sai. Nhưng quan trọng là mình không thấy hối hận hay ngồi đó gặm nhấm nỗi tiếc nuối, mà vẫn tiếp tục rút kinh nghiệm, học hỏi để tiến lên phía trước. Mình nghĩ vậy là đủ rồi.\nCảm ơn các bạn đã dành thời gian đọc bài viết này của mình!\n","date":"2023-05-18T18:44:00+07:00","image":"https://namanh11611.github.io/p/junior/junior_hu4810147118880557112.jpeg","permalink":"https://namanh11611.github.io/p/junior/","title":"Những điều giá như mình biết từ khi còn là Junior"},{"content":"Concept Trước hết, chúng ta cần hiểu DataStore sinh ra với mục đích là gì.\nHiện tại, trong ứng dụng Android, chúng ta có 5 cách để lưu trữ dữ liệu, trong đó SharedPreferences là cách dùng để lưu những dữ liệu đơn giản nhất. Nó chỉ gồm key và value, trong đó value có thể là integer, string\u0026hellip;\nKhi lần đầu mở app, nó sẽ đọc toàn bộ giá trị trong file xml của SharedPrefrences và lưu vào RAM. Quá trình đọc file này lại diễn ra trên UI Thread, nếu chúng ta có rất rất nhiều giá trị khiến cho thời gian thực hiện tác vụ vượt quá 5 giây, nó sẽ gây ra lỗi ANR (Application Not Responding).\nVà DataStore được tạo ra chính là để thay thế SharedPreferencs.\nDataStore là giải pháp lưu trữ dữ liệu theo dạng cặp key-value hoặc typed objects với protocol buffers.\nTất nhiên, DataStore vẫn chỉ dành để lưu những dữ liệu có cấu trúc đơn giản. Nó sử dụng Coroutines và Flow để lưu data một cách bất đồng bộ và nhất quán.\nDataStore gồm 2 loại Preferences DataStore và Proto DataStore, chúng ta cùng nhìn qua bảng so sánh sau:\nPreferences DataStore Proto DataStore Lưu và truy cập data bằng key Lưu instance của một loại custom data Không yêu cầu định nghĩa trước loại data Phải định nghĩa trước loại data bằng protocol buffers Không có type safety Có type safety Preferences DataStore Create Để sử dụng Preferences DataStore, chúng ta cần tạo một instance DataStore\u0026lt;Preferences\u0026gt; bằng property delegate với keyword preferencesDataStore.\n1 2 3 // At the top level of your kotlin file val Context.dataStore: DataStore\u0026lt;Preferences\u0026gt; by preferencesDataStore(name = \u0026#34;settings\u0026#34;) Read Trước hết, chúng ta có 7 function tương ứng với 7 loại data:\nintPreferencesKey() longPreferencesKey() doublePreferencesKey() floatPreferencesKey() booleanPreferencesKey() stringPreferencesKey() stringSetPreferencesKey() Khi đọc data, chúng ta cần dùng function tương ứng với giá trị mà chúng ta cần lưu. Ví dụ để lưu một biến counter dạng số nguyên để đếm số lần user mở app, chúng ta có thể dùng cách sau:\n1 2 3 4 5 6 val OPEN_APP_COUNTER = intPreferencesKey(\u0026#34;open_app_counter\u0026#34;) val openAppCounterFlow: Flow\u0026lt;Int\u0026gt; = context.dataStore.data .map { preferences -\u0026gt; // No type safety. preferences[OPEN_APP_COUNTER] ?: 0 } Điểm khác biệt với SharedPreferences chính là ở đây, data được trả về dưới dạng Flow. Giờ đây, các layer phía trên như Repository có thể observe data một cách thống nhất, không cần quan tâm nó đến từ DataStore, Room database hay Server, bởi vì tất cả đều được return dưới dạng Flow.\nWrite Để ghi dữ liệu, chúng ta dùng function edit, cũng khá giống với SharedPreferences.\n1 2 3 4 context.dataStore.edit { settings -\u0026gt; val openAppCounterValue = settings[OPEN_APP_COUNTER] ?: 0 settings[OPEN_APP_COUNTER] = openAppCounterValue + 1 } Proto DataStore Trước khi tìm hiểu về Proto DataStore, chúng ta cần dạo qua một vòng về protocol buffers.\nProtocol buffers Đây là một một kiểu định dạng dữ liệu mà không phụ thuộc vào ngôn ngữ lập trình hay platform. Nó giống như JSON nhưng nhỏ và nhanh hơn nhiều lần. Protocol buffers cũng được giới thiệu là định dạng dữ liệu được sử dụng phổ biến nhất tại Google.\nNó dùng để lưu các dữ liệu nhỏ gọn Phân tích cú pháp nhanh Hỗ trợ nhiều ngôn ngữ lập trình như C++, C#, Dart, Go, Java, Kotlin, Python Tối ưu hoá chức năng thông qua các class được generate tự động Ví dụ một message về thông tin user gồm tên, id và email:\n1 2 3 4 5 message UserProfile { optional string name = 1; optional int32 id = 2; optional string email = 3; } Để so sánh về hiệu năng so của Protocol buffers so với JSON, chúng ta thử gọi 500 GET requests từ một app Spring Boot này tới app Spring Boot khác với 2 môi trường có nén và không nén data. Và đây là kết quả: Chúng ta có thể thấy Protocol buffer nhanh hơn từ 5 đến 6 lần so với JSON.\nCreate Để sử dụng Proto DataStore, chúng ta phải định nghĩa loại data bằng một file proto settings.pb trong folder app/src/main/proto/ như sau:\n1 2 3 4 5 6 syntax = \u0026#34;proto3\u0026#34;; option java_package = \u0026#34;com.example.application\u0026#34;; option java_multiple_files = true; message Settings { int32 open_app_counter = 1; } Sau đó, tiếp tục khai báo một object implement class Serializer\u0026lt;T\u0026gt; với T là kiểu dữ liệu đã được định nghĩa trong proto file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 object SettingsSerializer : Serializer\u0026lt;Settings\u0026gt; { override val defaultValue: Settings = Settings.getDefaultInstance() override suspend fun readFrom(input: InputStream): Settings { try { return Settings.parseFrom(input) } catch (exception: InvalidProtocolBufferException) { throw CorruptionException(\u0026#34;Cannot read proto.\u0026#34;, exception) } } override suspend fun writeTo( t: Settings, output: OutputStream ) = t.writeTo(output) } Và cuối cùng là sử dụng property delegate với keyword dataStore để tạo một instance của DataStore\u0026lt;T\u0026gt;.\n1 2 3 4 val Context.settingsDataStore: DataStore\u0026lt;Settings\u0026gt; by dataStore( fileName = \u0026#34;settings.pb\u0026#34;, serializer = SettingsSerializer ) Read Tương tự như Preferences DataStore, chúng ta cũng dùng DataStore.data để trả về một Flow.\n1 2 3 4 5 val openAppCounterFlow: Flow\u0026lt;Int\u0026gt; = context.settingDataStore.data .map { settings -\u0026gt; // The openAppCounter is generated from the proto schema. settings.openAppCounter } Write Để ghi data vào Proto DataStore, chúng ta có function updateData().\n1 2 3 4 5 context.settingsDataStore.updateData { currentSettings -\u0026gt; currentSettings.toBuilder() .setExampleCounter(currentSettings.exampleCounter + 1) .build() } So sánh với SharedPreferences Migrate from SharedPreferences to Preferences DataStore Để migrate, chúng ta truyền SharedPreferencesMigration vào param produceMigrations. DataStore sẽ tự động migrate cho chúng ta.\n1 2 3 4 5 6 7 8 9 val Context.dataStore: DataStore\u0026lt;Preferences\u0026gt; by preferencesDataStore( name = DATA_STORE_NAME produceMigrations = { context -\u0026gt; listOf(SharedPreferencesMigration( context, SHARED_PREFERENCES_NAME )) } ) Migrate from SharedPreferences to Proto DataStore Trước tiên, chúng ta cần khai báo UserProfile và UserProfileSerializer tương tự như các bước ở trên. Sau đó viết một mapping function để migrate từ cặp key-value trong SharedPreferences sang loại dữ liệu trong Proto DataStore.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val Context.dataStore: DataStore\u0026lt;UserProfile\u0026gt; by dataStore( fileName = \u0026#34;settings.pb\u0026#34;, serializer = UserProfileSerializer, produceMigrations = { context -\u0026gt; listOf( SharedPreferencesMigration( context, \u0026#34;settings_pref\u0026#34; ) { prefs: SharedPreferencesView, user: UserProfile -\u0026gt; user.toBuilder() .setName(prefs.getString(NAME_KEY)) .setId(prefs.getInt(ID_KEY)) .setEmail(prefs.getString(EMAIL_KEY)) .build() } ) } ) References https://developer.android.com/topic/libraries/architecture/datastore https://protobuf.dev/programming-guides/proto3 https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html https://stackoverflow.com/questions/9986734/which-android-data-storage-technique-to-use https://auth0.com/blog/beating-json-performance-with-protobuf https://proandroiddev.com/is-jetpack-datastore-a-replacement-for-sharedpreferences-efe92d02fcb3 https://kinya.hashnode.dev/migrating-sharedpreferences-to-datastore-ckxzlvda101by8rs1c8bg4wdx https://amitshekhar.me/blog/jetpack-datastore-preferences ","date":"2023-05-14T15:41:00+07:00","image":"https://namanh11611.github.io/p/data-store/datastore_hu16035211694851743359.jpeg","permalink":"https://namanh11611.github.io/p/data-store/","title":"DataStore - mảnh ghép hoàn hảo cho bức tranh Kotlin Coroutines"},{"content":"Khái niệm Trước đây mình cũng chưa biết về Delegation Pattern, cho đến khi học Kotlin thì thấy người ta hay dùng keyword by trong lúc khai báo một biến. Vậy là thử tìm hiểu thì cả một chân trời mở ra về pattern mới này.\n~~ Hơi đao to búa lớn quá rồi 😅😅 ~~\nĐể cho dễ hiểu thì Delegation dịch ra tiếng Việt là Sự uỷ nhiệm. Nhưng mình nghĩ là chúng ta sẽ dùng các từ \u0026ldquo;delegation\u0026rdquo; và \u0026ldquo;delegate\u0026rdquo; thay cho từ \u0026ldquo;sự uỷ nhiệm\u0026rdquo; và \u0026ldquo;uỷ nhiệm\u0026rdquo; để giữ gìn sự trong sáng của tiếng Anh. Đùa vậy thôi chứ trong công việc hay lúc đi phỏng vấn, các bạn nên dùng từ gốc tiếng Anh để cho chuyên nghiệp và đối phương cũng dễ nắm bắt ý của mình nhé.\nThe Delegation Pattern is an object-oriented design pattern that allows object composition to achieve the same code reuse as inheritance.\nDịch nôm na: Delegation Pattern cho phép object tái sử dụng code tương tự như kế thừa.\nTrong delegation, chúng ta có 2 thành phần:\nReceiving object Delegate object Khi có một request cần handle, receiving object sẽ không trực tiếp handle nó mà delegate tác vụ đó cho delegate object. Nó giống như việc bạn có một ông anh và bà chị rất giỏi Toán, mỗi lần cô giáo giao bài tập về nhà, bạn lại nhờ họ làm hộ vậy.\nƠ thế nó khác gì Kế thừa nhỉ? Trong Kế thừa chúng ta cũng có thể gọi đến method của parent class mà?\nĐúng là Kế thừa rất hữu ích nhưng chúng ta chỉ dùng khi child class thực sự có liên quan về mặt ý nghĩa chính xác với parent class. Ví dụ như class Cat có thể kế thừa class Animal nhưng không nên kế thừa class Transportation vậy. Chưa kể child class phải override tất cả các abstract method của parent class, đôi khi điều đó là không cần thiết. Vậy nên Delegation giúp chúng ta linh hoạt hơn.\nVí dụ minh hoạ Quay trở lại với ví dụ ban nãy, giả sử bạn có một ông anh là kỹ sư và một bà chị là bác sỹ. Họ đều là những người rất tài năng.\n1 2 3 4 5 6 7 8 9 10 11 interface TalentPerson { fun doHomework() } class Engineer : TalentPerson { override fun doHomework() {} } class Doctor : TalentPerson { override fun doHomework() {} } Còn bạn là một học sinh hơi lười một chút nên cần đến một class helper, với param là một người tốt bụng nào đó luôn sẵn sàng giúp đỡ bạn mọi lúc khó khăn.\n1 2 3 4 5 class LazyStudentHelper(private val kindPerson: TalentPerson) { fun doHomeworkByMyself() { kindPerson.doHomework() } } Vậy là bây giờ, mỗi lần giáo viên giao bài tập về nhà, bạn sẽ lại nhờ đến ông anh hoặc bà chị làm hộ.\n1 2 3 4 5 6 7 8 9 fun main() { val brother = Engineer() val lazyBoy = LazyStudentHelper(brother) lazyBoy.doHomeworkByMyself() val sister = Doctor() val lazyGirl = LazyStudentHelper(sister) lazyGirl.doHomeworkByMyself() } Delegation Pattern trong Kotlin Keyword by trong Kotlin Trong Kotlin đã support Delegation Pattern thông qua keyword by, giúp chúng ta giảm boilerplate code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class LazyStudentHelper( private val kindPerson: TalentPerson ): TalentPerson by kindPerson fun main() { val brother = Engineer() val lazyBoy = LazyStudentHelper(brother) lazyBoy.doHomework() val sister = Doctor() val lazyGirl = LazyStudentHelper(sister) lazyGirl.doHomework() } Giờ đây, class LazyStudentHelper phải implement interface TalentPerson, qua đó nó có thể delegate method doHomework qua instance kindPerson.\nDelegated properties Chúng ta có một số cách để ứng dụng Delegation khi khai báo biến trong Kotlin:\nLazy properties: giá trị sẽ được tính toán trong lần đầu tiên access. Observable properties: listeners sẽ được thông báo về những thay đổi của property này. Lazy properties lazy là một function có param là lambda và trả về kết quả là một instance của class Lazy\u0026lt;T\u0026gt;.\n1 2 3 4 5 6 7 8 9 val lazyValue: String by lazy { println(\u0026#34;computed!\u0026#34;) \u0026#34;Hello\u0026#34; } fun main() { println(lazyValue) println(lazyValue) } Lần gọi biến lazyValue đầu tiên sẽ tính toán kết quả và lưu lại giá trị, những lần gọi sau chỉ trả về giá trị mà không cần tính toán kết quả. Vậy nên kết quả in ra sẽ là:\n1 2 3 computed! Hello Hello Observable properties 1 2 3 4 5 6 7 8 9 10 11 12 13 import kotlin.properties.Delegates class User { var name: String by Delegates.observable(\u0026#34;\u0026lt;no name\u0026gt;\u0026#34;) { prop, old, new -\u0026gt; println(\u0026#34;$old -\u0026gt; $new\u0026#34;) } } fun main() { val user = User() user.name = \u0026#34;first\u0026#34; user.name = \u0026#34;second\u0026#34; } Delegates.observable() có 2 argument:\nGiá trị khởi tạo Function để xử lý khi biến name thay đổi. Nó được gọi mỗi khi chúng ta assign giá trị cho biến. Kết quả như sau:\n1 2 \u0026lt;no name\u0026gt; -\u0026gt; first first -\u0026gt; second Reference https://en.wikipedia.org/wiki/Delegation_pattern https://kotlinlang.org/docs/delegation.html https://kotlinlang.org/docs/delegated-properties.html ","date":"2023-05-12T16:50:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-delegation/delegation_hu12573926655221623983.jpeg","permalink":"https://namanh11611.github.io/p/design-pattern-delegation/","title":"Design Pattern: Delegation trong Kotlin - cách để nhờ người khác làm bài tập về nhà"},{"content":"Hoàn cảnh Hôm vừa rồi một người em bên Nhật chia sẻ với mình rằng muốn mở công ty ở Việt Nam, nhưng chưa hiểu về thị trường hiện tại ở Việt Nam lắm. Mình đành dốc hết những kiến thức nông cạn của mình ra chia sẻ với em về môi trường, công việc cũng như lương thưởng của anh em dev ở Hà Nội, thành phố Hồ Chí Minh và Đà Nẵng\u0026hellip;\nDẫu biết rằng thị trường đang ảm đạm, làn sóng sa thải cũng đã lan đến Việt Nam từ cuối năm 2022 đến thời điểm hiện tại là tháng 5/2023, nhưng thật sự chưa có một báo cáo đáng tin cậy để đánh giá về tình hình năm 2023 này. Vậy nên mình sẽ dựa vào báo cáo gần nhất của 2 bên TopDev và ITViec trong năm 2022 để đưa ra góc nhìn về mức lương thưởng của anh em.\nTrong báo cáo của TopDev có đưa ra cả đánh giá về tình hình tuyển dụng, nhưng mình nghĩ rằng gió đã đổi chiều nên những đánh giá đó không còn chính xác trong năm 2023 này. Còn về lương thưởng, khác với tình hình năm 2020 khi các công ty giảm lương nhân viên để vượt qua giai đoạn khó khăn, trong năm 2023 này, hầu hết các công ty chỉ đưa ra lựa chọn giữ người hoặc sa thải, vậy nên mức lương của những người ở lại sẽ ít bị ảnh hưởng.\nITViec khảo sát 1.257 chuyên gia IT còn TopDev thì dựa trên 48.179 ứng viên IT, 100.000 dữ liệu việc làm được phân tích và thông tin của 2.500 nhà tuyển dụng. Bởi vì khảo sát với một volumn nhỏ thì sẽ có sự sai lệch nhất định so với thị trường, vậy nên mình mới dùng báo cáo của cả 2 bên để mong rằng giảm tối đa sự sai lệch đó và giúp chúng ta có một góc nhìn khách quan nhất.\nMức lương theo công nghệ Trong biểu đồ trên, TopDev thể hiện mức lương của các dev từ 3 năm kinh nghiệm trở xuống. Vậy nên mình thấy nó hơi thấp và không phản ánh được mức lương của senior dev có từ 4-5 năm kinh nghiệm trở lên.\nTop công nghệ được trả lương cao nhất gồm các công nghệ theo xu hướng như AI (Kubernetes, TensorFlows, Python), Cloud Computing (AWS, GCP, Azure). Unity cũng lọt top nhờ trend play-to-earn nổi đình nổi đám trong năm 2022.\nBảng số liệu của ITViec thể hiện chi tiết hơn mức lương cho từng ngôn ngữ lập trình theo số năm kinh nghiệm. Python vẫn là một trong những ngôn ngữ được trả lương cao, nhưng Go - một ngôn ngữ đang trở thành trending - mới là vũ khí giúp anh em dev được trả lương cao nhất.\nMức lương theo vị trí Biểu đồ này của TopDev vẫn thể hiện mức lương của các dev từ 3 năm kinh nghiệm trở xuống.\nCác vị trí CTO, CIO hoặc Tech Management vốn vẫn được coi là mục tiêu nghề nghiệp cao nhất, họ phải nắm các kỹ năng cơ bản vững chắc, xử lý các công việc quản lý, tối ưu hóa công nghệ / sản phẩm và điều chỉnh kịp thời.\nCác vị trí được trả lương cao tiếp theo yêu cầu các kỹ năng đặc biệt như Data, Cloud, DevOps hoặc AI.\nTrong bảng số liệu của ITViec, các vị trí trên vẫn được trả mức lương rất tốt. Nhưng đối với các dev từ 5 năm kinh nghiệm trở lên trong lĩnh vực khác (Front-end, Mobile), họ cũng được trả mức lương không hề kém cạnh.\nĐiều này chứng minh rằng bạn không cần phải luôn chạy theo những công nghệ hot, chỉ cần bạn đủ giỏi, thì với vị trí nào, bạn cũng được trả mức lương tương xứng.\nMức lương theo trình độ TopDev chỉ đưa ra một biểu đồ chung về mức lương theo số năm kinh nghiệm. Trong 5 năm đầu tiên, lương của lập trình viên dao động từ $350 (Fresher) đến dưới $1.190 cho Mid-Senior. Đối với các lập trình viên từ 5 năm kinh nghiệm, mức lương chênh lệch chủ yếu dựa trên vị trí và trách nhiệm đối với hoạt động kinh doanh. Giám đốc hoặc cấp cao hơn sẽ có mức lương ít nhất là $2.300. Mức lương của cấp quản lý kỹ thuật sẽ cao hơn so với cấp quản lý/giám đốc theo định hướng kinh doanh.\nMức lương theo thành phố Có lẽ nhiều anh em cũng đã biết trước kết quả về bảng số liệu này của ITViec. Nhìn chung thì mức lương ở thành phố Hồ Chí Minh cao hơn Hà Nội, và Hà Nội thì lại cao hơn Đà Nẵng.\nTheo mình có lẽ vì thành phố Hồ Chí Minh gồm nhiều công ty product và outsource làm với thị trường nói tiếng Anh hơn. Còn ở Hà Nội vẫn gồm nhiều các công ty làm cho thị trường Nhật. Tuy nhiên trong giai đoạn gần đây, đã có nhiều công ty từ thành phố Hồ Chí Minh Bắc tiến ra Hà Nội, điều đó cũng đã giúp thị trường ở Hà Nội nhộn nhịp hơn rất nhiều.\nLời kết Cũng phải nhìn nhận rằng, những anh em không may bị sa thải trong giai đoạn này sẽ phải tìm một công việc mới và có thể phải chấp nhận một mức lương thấp hơn mức cũ. Điều đó cũng góp phần làm cho mức lương của thị trường hiện tại thấp hơn mức trong khảo sát.\nNhưng mình hy vọng rằng dựa vào báo cáo này, anh em có thêm một góc nhìn khác về thị trường, để biết cách trau dồi bản thân, rèn luyện kỹ năng. Và sau cơn mưa trời lại sáng, khi thị trường sôi động trở lại, với những kỹ năng đã được nâng cấp, anh em sẽ nhận được một mức lương xứng đáng với năng lực.\nReference https://topdev.vn/page/bao-cao-it-viet-nam https://itviec.com/blog/bao-cao-luong-it ","date":"2023-05-10T01:40:00+07:00","image":"https://namanh11611.github.io/p/salary/salary_hu1443487870289924233.jpeg","permalink":"https://namanh11611.github.io/p/salary/","title":"Tình hình lương thưởng của anh em IT"},{"content":"Lời mở đầu Lúc mới nghe đến Kotlin Multiplatform (từ nay xin được viết tắt là KM), tại hạ trộm nghĩ \u0026ldquo;Công nghệ quái gì mà chỉ share được mỗi logic code? Muốn code nhanh thì người ta làm luôn bằng Flutter cho rồi, performance có kém gì đâu\u0026rdquo;. Thế rồi dòng đời xô đẩy, tại hạ được tham dự vào một project đang áp dụng KM, quả nhiên đã được mở mang tầm mắt về những ưu cũng như nhược điểm của nó. Nay mượn chén rượu dưới đêm trăng, xin được lạm bàn mấy lời, hầu chuyện chư vị huynh đệ.\nKotlin Multiplatform là cái gì? KM giúp việc phát triển các cross-platform projects trở nên nhẹ tựa lông hồng. Nó giúp giảm thời gian viết và maintain code nhưng vẫn giữ được những ưu điểm của native cho từng platform. Kotlin app có thể chạy trên Android, iOS, macOS, Windows, Linux, watchOS\u0026hellip;\nMặc dù KM vẫn đang trong giai đoạn Beta nhưng nó cũng đã khá ổn định và được áp dụng ở nhiều công ty như 9gag, Netflix, Philips, Baidu, VMWare, Quizlet, Memrise\u0026hellip;\nTrở lại với câu hỏi đầu bài, vậy thì KM có những ưu điểm gì so với các cross-platform framework khác?\nThực sự thì KM phù hợp với những project có logic code phức tạp. Chúng ta đều biết rằng viết càng nhiều code thì càng sinh ra nhiều bug, chỉ có một cách duy nhất để không gây ra bug đó là No Code. Vậy nên thay vì việc Android dev viết logic code cho Android, iOS dev viết logic code cho iOS, thì giờ đây chỉ cần viết logic code 1 lần cho KM cũng đã giúp giảm một nửa lượng bug phát sinh rồi.\nVí dụ với một project cần 10 Android dev và 10 iOS dev, nếu áp dụng KM thì bây giờ chỉ cần 5 Android dev, 5 iOS dev và 5 dev code KM (có thể là Android dev luôn). Như vậy là project đã giảm được 25% resource rồi. So với Flutter, đương nhiên là chúng ta vẫn tốn resource hơn, nhưng đánh đổi lại là native performance.\nUse Cases Android và iOS app Chúng ta có thể share business logic code giữa các nền tảng để build một cross-platform mobile app. Đây cũng chính là use case chính của KM tại thời điểm này. Ví dụ các bạn có thể viết code từ ViewModel đến Data layer trong KM, còn bên phía Android và iOS app chỉ đơn thuần là build UI bằng Jetpack Compose và SwiftUI.\nFull-stack web app Có thể các bạn không biết nhưng bây giờ Kotlin đã có thể dùng để viết Front-end web app. Như vậy hoàn toàn có thể build một full-stack web app với server dùng Kotlin/JVM và web client dùng Kotlin/JS. Do đó, chúng ta cũng có thể dùng KM để tái sử dụng logic code cho cả server và client.\nMultiplatform libraries Nếu Kotlin đã có thể build được cho cả Android, iOS, và web thì tại sao chúng ta không viết một library mà có thể dùng cho cả 3 platform? Với những project mà các bạn cần build cho cả app và web, hãy thử dùng KM để viết common code, publish nó như một library, và ở app hay web, bạn có thể import nó như một dependency.\nCommon code cho mobile và web app Thậm chí, bạn không cần tạo library mà có thể viết trực tiếp code để share giữa Android, iOS, desktop và web app. Cách làm này giúp giảm khối lượng công việc cho anh em mobile và front-end web dev, vì chúng ta chỉ phải viết logic code một lần duy nhất. Đồng thời nó cũng giúp giảm bug, giảm thời gian viết test.\nCách hoạt động Vậy làm thế nào mà KM có thể shared code cho tất cả các platform? Common Kotlin là phần code bao gồm core libraries, có thể chạy trên tất cả platform. Với KM libraries, chúng ta có thể tái sử dụng multiplatform logic trong common và platform-specific code. Platform-specific code (Kotlin/JVM, Kotlin/JS, Kotlin/Native) bao gồm extensions cho Kotlin, platform-specific libraries và tools. Với từng platform, chúng ta có thể tận dụng platform native code (JVM, JS và Native). Ví dụ, để viết một function generate UUID cho cả Android và iOS, chúng ta có thể khai báo một function với keyword expect trong common module như sau:\n1 2 // Common expect fun randomUUID(): String Sau đó, với mỗi platform, chúng ta lại viết các function implement với keyword actual như sau:\n1 2 3 4 // Android import java.util.* actual fun randomUUID() = UUID.randomUUID().toString() 1 2 3 4 // iOS import platform.Foundation.NSUUID actual fun randomUUID(): String = NSUUID().UUIDString() Bóc trần công nghệ Project của mình apply KM cho Android và iOS app. Mình đặt ra câu hỏi là tại sao Kotlin có thể integrate được với iOS app viết bằng Swift?\nVà câu trả lời của Jet Brains là họ dùng Kotlin/Native để compile Kotlin code sang native binaries, do đó có thể chạy Kotlin code mà không cần virtual machine. Nó bao gồm backend dựa trên LLVM cho Kotlin compiler và native implementation của Kotlin standard library.\nKotlin/Native được thiết kế để compile cho các platform mà không chạy được virtual machine như là embedded devices hoặc iOS.\nCòn bên phía Android, Kotlin code được compile sang JVM bytecode bằng Kotlin/JVM.\nLời kết Trong tương lai, Jet Brains không chỉ dừng lại với Kotlin Multiplatform mà đang có kế hoạch phát triển Compose Multiplatform, nghĩa là thay vì share logic code thì có thể share cả UI như các cross-platform framework khác (Flutter, React Native). Đấy là cả một chặng đường dài, chư vị huynh đệ hãy cùng ngồi xuống đây ăn miếng thịt to, uống bát rượu lớn rồi cùng chờ xem hồi sau sẽ rõ.\nReference https://kotlinlang.org/docs/multiplatform.html https://kotlinlang.org/docs/multiplatform-mobile-faq.html#what-is-kotlin-native-and-how-does-it-relate-to-kotlin-multiplatform ","date":"2023-05-07T13:37:00+07:00","image":"https://namanh11611.github.io/p/kotlin-multiplatform/kotlin_hu14566633691824355305.jpeg","permalink":"https://namanh11611.github.io/p/kotlin-multiplatform/","title":"Kotlin Multiplatform - Kẻ ngáng đường Flutter, React Native?"},{"content":"Case study Câu chuyện đầu tiên Ở công ty cũ của mình (tạm gọi là công ty A), source code của dự án siêu to khổng lồ, mới clone về đã 40GB, compile và build các kiểu thì còn lên đến gần 100GB. Mỗi lần anh em code một feature nào đó, thường sẽ checkout ra một branch mới là feature_x. Feature nhỏ thì không sao, chứ feature lớn mà thay đổi vài chục hay đến cả trăm file, xong merge vào branch chính thì đúng là ác mộng, vì phải resolve conflict từ code của branch feature_a, feature_b nào đó merge trước đó.\nCâu chuyện thứ hai Ở công ty khác của mình (công ty B), do đặc thù của dự án mà project được chia thành 5 team nhỏ, mỗi team tầm 3 developer. Mỗi team nhỏ sẽ phụ trách một vài feature trong 1 sprint. Khi bắt đầu sprint, dev lead tạo branch cho từng team, và sẽ merge 5 branch đó sau khi kết thúc sprint. Vấn đề phát sinh tương tự là merge code xảy ra khá nhiều conflict, và các team lại mất thời gian test lại feature của mình để đảm bảo không xảy ra bug sau khi merge.\nVậy Trunk Based Development là gì? Nói một cách ngắn gọn, Trunk Based Development (từ sau mình sẽ viết tắt TBD) là một source-control branching model (mô hình làm việc với các nhánh) mà tất cả developers sẽ làm việc trên một branch duy nhất, gọi là trunk (nghĩa là cái thân cây), tránh việc tạo ra các feature branch siêu to khổng lồ. Trunk branch cần đảm bảo rằng nó có thể sẵn sàng release bất cứ thời điểm nào. Trong các dự án, mọi người thường sẽ đặt tên cho trunk branch là master hoặc dev.\nTBD lại chia thành 2 mô hình nhỏ hơn, phù hợp với từng team. Chúng ta sẽ cùng đi tìm hiểu ngay sau đây.\nTBD cho team nhỏ Trong mô hình này, toàn bộ dev team sẽ push code trực tiếp lên trunk branch. Tuy nhiên, mô hình này mình thấy có rủi ro rất lớn về chất lượng code, vì code được push trực tiếp mà không qua review. Vậy nên, để áp dụng mô hình này, các dev tham gia project cũng phải có technical skill rất tốt, để đảm bảo rằng từng dòng code mình push lên không gây bug cho tất cả anh em.\nCá nhân mình đánh giá mô hình này có lẽ chỉ phù hợp với team size từ 5 người trở xuống.\nTBD cho team to Với TBD cho một team lớn, các feature branch vẫn được tạo, nhưng điểm khác biệt là nó chỉ được tạo trong một thời gian ngắn, chỉ vài commit là merge lại trunk branch ngay.\nVí dụ khi được giao task code Onboarding feature, với Git flow mà thông thường mọi người đang áp dụng, các bạn sẽ làm những bước như sau:\nTạo feature/onboarding branch Code Welcome screen rồi commit Code Register screen rồi commit tiếp Code Login screen rồi commit nữa Code xong hết rồi thì tạo merge request, chờ dev khác review code Review xong thì merge feature/onboarding branch vào dev branch Với quy trình như trên, merge request có thể chứa vài chục file thay đổi, và review đống code ấy thực sự là ác mộng. Đôi khi, vào thời điểm chúng ta tạo merge request, còn xảy ra conflict với code của một feature nào đó đã merge vào dev branch trước. Và chúng ta lại phải hì hục ngồi resolve conflict.\nĐối với reviewer, đôi khi cách để thoát khỏi ác mộng là không mơ nữa, nghĩa là bác senior dev sẽ nhanh chóng để lại dòng comment ngắn gọn LGTM (Look good to me), vậy là anh chàng junior dev dễ dàng merge code vào dev branch. Hoặc mặc dù bác senior dev đã cố gắng review cẩn thận, nhưng với lượng code thay đổi lớn như vậy thì vẫn bị lọt một vài bug. Tựu chung lại thì quy trình này vẫn có rủi ro trong việc để lọt bug.\nĐối với TBD, quy trình sẽ điều chỉnh lại một chút như sau:\nTạo feature/welcome_screen branch Code Welcome screen rồi commit, tạo merge request luôn Trong lúc chờ review thì code Register screen tiếp Khi Merge request của Welcome screen được approve, lại checkout ra feature/register_screen branch để tạo merge request mới Tương tự như vậy với Login screen Giờ đây, mỗi merge request của chúng ta chỉ chứa vài file thay đổi, bác senior dev có thể review code dễ dàng hơn.\nVà kể cả khi branch release có bug, chúng ta cần hotfix thì dev cũng không merge trực tiếp vào release branch như các mô hình khác, mà tất cả đều phải merge vào trunk branch.\nFeature flag Các bạn có thể thắc mắc rằng làm như vậy thì trên dev branch sẽ chứa đầy code dở dang của các feature. Ví dụ app sẽ hiển thị Welcome screen với UI mới, trong khi Register và Login screen thì vẫn là UI cũ. Như vậy, làm sao có thể đảm bảo rằng trunk branch có thể release bất cứ lúc nào?\nChìa khoá để giải quyết vấn đề này chính là Feature flag. Với mỗi feature dang dở như vậy, bạn cần đặt cho nó một cái flag, để khi bật flag, tất cả code của feature mới sẽ hoạt động, còn nếu tắt flag, app sẽ hoạt động như code hiện tại. Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if (ONBOARDING_FLAG == FLAG_ON) { displayNewWelcomeScreen() } else { displayOldWelcomeScreen() } if (ONBOARDING_FLAG == FLAG_ON) { displayNewRegisterScreen() } else { displayOldRegisterScreen() } if (ONBOARDING_FLAG == FLAG_ON) { displayNewLoginScreen() } else { displayOldLoginScreen() } Đôi khi, bạn muốn revert một feature thì cũng chỉ cần tắt flag của nó đi là xong. Quá nhanh chóng phải không nào?\nƯu điểm Giảm conflict, giảm thời gian review code Như mình đã trình bày ở trên, TBD yêu cầu mọi người phải nhanh chóng merge code của mình vào trunk branch, điều này giúp giảm conflict code, đồng thời giảm thời gian review code.\nVới case study thứ 2 của công ty B, sau một thời gian thấy mô hình hiện tại không hiệu quả, mình đã đề xuất với dev lead áp dụng TBD. Và đúng như mong đợi, với mỗi sprint, hầu như team mình không còn phải dành quá nhiều thời gian resolve conflict nữa.\nCI/CD TBD thực sự rất hữu ích cho CI/CD. Nghĩ mà xem, giờ đây bạn chỉ cần setup và run CI/CD trên một branch duy nhất. Tất cả những commit của mọi người sẽ nhanh chóng được check coding convention, unit test cẩn thận, giúp cả team dễ dàng phát hiện ra lỗi sai và fix nó kịp thời.\nA/B Testing Với feature flag, bạn cũng dễ dàng bật tắt các feature, giúp Product Manager thuận tiện setup các A/B Testing. Từ đó có thể đo lường để đưa ra đánh giá chính xác về hiệu quả của một feature mới.\nỞ case study thứ nhất của công ty A, thực sự thì chúng mình đã apply feature flag cho rất nhiều feature quan trọng để thực hiện A/B testing.\nNhanh chóng deliver sản phẩm Vì code ở trunk branch luôn sẵn sàng release nên mình thấy nó khá phù hợp với các start-up. Bất cứ khi nào bạn muốn release một version mới, chỉ cần checkout từ trunk branch, bật các feature flag đã hoàn thành và tắt các feature flag còn dang dở, rồi build code.\nNhược điểm Quá nhiều code dư thừa Nói đi cũng phải nói lại, việc áp dụng feature flag và if else quá nhiều có thể khiến code của bạn trở nên phức tạp. Đôi khi có một số function, code if else không clear có thể khiến reviewer còn cảm thấy khó hiểu hơn.\nVà khi một feature được release, bạn cũng lại phải quay lại để xoá code flow cũ đi, như các function displayOldWelcomeScreen, displayOldRegisterScreen và displayOldLoginScreen trong ví dụ trên.\nKhông phù hợp với team có nhiều junior Việc tạo merge request liên tục yêu cầu các dev phải cẩn trọng, đảm bảo rằng mỗi commit của mình đã pass tất cả coding convention check hay unit test ở local, và đặc biệt là không có critical bug. Vì nếu có bug trên trunk branch khiến cho không thể mở được app chẳng hạn, nó sẽ block công việc của tất cả các dev khác.\nNếu dùng feature flag, dev còn cần test cả 2 flow cũ và mới để đảm bảo cả 2 đều hoạt động đúng.\nVậy nên mình nghĩ rằng một team gồm chủ yếu là senior sẽ phù hợp hơn với mô hình này.\nLời kết TBD là một mô hình làm việc mà mình đã áp dụng ở một số công ty và thấy nó hoạt động khá hiệu quả với tình hình của team mình lúc đó. Các bạn có thể nghiên cứu ưu, nhược điểm của mô hình so với team mình và áp dụng thử nhé.\nReference https://trunkbaseddevelopment.com/ ","date":"2023-05-03T02:07:00+07:00","image":"https://namanh11611.github.io/p/trunk-based-development/tbd_hu15319306288030497913.jpeg","permalink":"https://namanh11611.github.io/p/trunk-based-development/","title":"Trunk Based Development - một Git workflow giúp giảm cơn đau đầu resolve conflict"},{"content":"Dispatcher là cái gì? Hiểu một cách đơn giản, Dispatcher sẽ quyết định xem Coroutines được thực thi trên thread nào. Có thể là main thread, background thread, hoặc nó đẩy Coroutines vào thread pool.\nCó 4 loại Dispatchers:\nDispatchers.Default Dispatchers.Main Dispatchers.IO Dispatchers.Unconfined Hoặc bạn có thể tự tạo Dispatchers cho riêng mình bằng function newSingleThreadContext() hoặc newFixedThreadPoolContext().\nCác function để build Coroutines như launch và async đều có một param là CoroutinesContext để chúng ta truyền Dispatchers vào, vì mấy thằng Dispatchers ở trên đều extends từ CoroutinesContext.\n1 2 3 launch(Dispatchers.Default) { println(\u0026#34;I\u0026#39;m working in thread ${Thread.currentThread().name}\u0026#34;) } Còn khi mà chúng ta gọi launch với async mà không truyền param CoroutinesContext, nó sẽ kế thừa context của CoroutineScope mà nó được khởi chạy.\n1 2 3 4 5 fun main() = runBlocking\u0026lt;Unit\u0026gt; { launch { println(\u0026#34;I\u0026#39;m working in thread ${Thread.currentThread().name}\u0026#34;) } } Ở trong ví dụ này, nó sẽ kế thừa context của runBlocking nên sẽ thực thi trên main thread.\nBây giờ, chúng ta sẽ đi tìm hiểu chi tiết từng loại Dispatchers nhé.\nDispatchers.Default Dispatchers.Default được dùng mặc định bởi các builder function launch và async nếu như chúng ta không gán Dispatchers nào khác cho nó. Default Dispatchers dùng một shared background threads pool. Vì vậy chúng ta có thể dùng Dispatchers.Default cho những công việc tốn nhiều CPU. Ví dụ:\nCác tác vụ nặng như tính toán ma trận Sort, filter hoặc search một cái list siêu to khổng lồ trên bộ nhớ Các tác vụ với Bitmap trên bộ nhớ Parse JSON trên bộ nhớ Mặc định, số lượng thread nhiều nhất được Dispatchers.Default dùng sẽ bằng với số CPU core, nhưng ít nhất là 2.\nDispatchers.Main Bạn nghe tên là đoán được rồi đúng không? Chính xác, Dispatchers.Main sẽ thực thi trên main thread, nó phù hợp với các tác vụ tương tác với UI.\nThông thường thì Dispatchers.Main sẽ là single thread.\nDispatchers.IO Nghe nhạc hiệu đoán được chương trình tiếp này. Dispatchers.IO dùng một shared pool gồm các thread được tạo theo nhu cầu. Nó giúp giảm tải các tác vụ blocking IO. Vì vậy nó phù hợp với các tác vụ liên quan đến disk và network. Ví dụ:\nGọi API Download file từ server Move 1 file từ folder này đến folder khác trên disk Đọc ghi file Query database Loading Shared Preferences Số lượng thread được sử dụng bởi Dispatchers.IO được giới hạn bởi 64 hoặc số lượng core (tuỳ xem số nào lớn hơn).\nDispatchers.Unconfined Mình gọi Dispatchers.Unconfined là con ngựa bất kham, vì mình sẽ không biết nó được thực thi trên thread nào.\nBan đầu, khi khởi chạy, Coroutines sẽ được thực thi trên chính thread gọi nó. Nhưng sau khi bị suspend, và resume, nó sẽ thực thi trên một thread khác, được quyết định bởi suspend functions được gọi. Dispatchers.Unconfined phù hợp với những công việc không tiêu tốn CPU và không update UI. Nhưng bản thân Kotlin document cũng nhấn mạnh là:\nThe Unconfined dispatcher should not normally be used in code.\nTạm dịch: Bình thường không ai dùng dispatcher Unconfined trong code cả.\nnewSingleThreadContext Function này sẽ tạo một thread mới cho chúng ta tha hồ vùng vẫy. Nhưng thật sự thì việc tạo một thread mới tốn rất nhiều resource, và bạn phải tự gọi function close để giải phóng nó khi không dùng nữa. Vậy nên trong thực tế, mình khuyến nghị các bạn không nên dùng cách này.\nNgoài ra còn có newFixedThreadPoolContext để tạo một thread pool với size cố định.\nSo sánh với RxJava, RxAndroid Chúng ta có thể thấy Dispatchers tương tự như Schedulers trong RxJava.\nCoroutines RxJava/RxAndroid Dispatchers.Default Schedulers.computation() Dispatchers.Main AndroidSchedulers.mainThread() Dispatchers.IO Schedulers.io() Lời kết Tựu chung lại, Dispatchers là một khái niệm quan trọng trong Coroutines, vậy nên các bạn cần nắm chắc về nó để có thể chọn một Dispatchers phù hợp cho từng function của mình.\nReference https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html https://amitshekhar.me/blog/dispatchers-in-kotlin-coroutines ","date":"2023-05-01T00:22:00+07:00","image":"https://namanh11611.github.io/p/kotlin-coroutines-dispatchers/dispatchers_hu13258851521858695155.jpeg","permalink":"https://namanh11611.github.io/p/kotlin-coroutines-dispatchers/","title":"Dispatchers trong Kotlin Coroutines"},{"content":"Đi tìm một Bottom Navigation Bar ưng ý Gần đây, trong quá trình làm dự án ở công ty, mình được tìm hiểu thêm về Flutter. Đó đúng là một framework giúp build mobile app cross platform rất nhanh. Theo một số bài đo đạc đánh giá thì Flutter còn có hiệu năng gần bằng native (Kotlin và Swift), đương nhiên là vượt xa React Native.\nỞ dự án này, mình được toàn quyền quyết định UI/UX của app. Vậy nên, mình muốn cải thiện thêm Bottom Navigation Bar, muốn nó trônng màu mè hơn một chút, thay vì dùng Bottom Navigation Bar mặc định của Flutter. Thế là sau một hồi lang thang trên Google, mình tìm thấy package curved_navigation_bar, tuy nhiên thì package này lại chỉ cho hiển thị icon ở Bottom Navigation Bar item như thế này.\nPhần code example:\n1 2 3 4 5 6 7 8 9 bottomNavigationBar: CurvedNavigationBar( items: \u0026lt;Widget\u0026gt;[ Icon(Icons.add, size: 30), Icon(Icons.list, size: 30), Icon(Icons.compare_arrows, size: 30), Icon(Icons.call_split, size: 30), Icon(Icons.perm_identity, size: 30), ], ) Mình muốn thêm label cho từng item thì chỉ có thể thêm bằng cách thay đổi mỗi item thành một Column widget:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bottomNavigationBar: CurvedNavigationBar( items: \u0026lt;Widget\u0026gt;[ Column( children: [Icon(Icons.add, size: 30), Text(\u0026#34;Add\u0026#34;)], ), Column( children: [Icon(Icons.list, size: 30), Text(\u0026#34;List\u0026#34;)], ), Column( children: [Icon(Icons.compare_arrows, size: 30), Text(\u0026#34;Compare\u0026#34;)], ), Column( children: [Icon(Icons.call_split, size: 30), Text(\u0026#34;Split\u0026#34;)], ), Column( children: [Icon(Icons.perm_identity, size: 30), Text(\u0026#34;Person\u0026#34;)], ), ], ) Và kết quả sẽ trở thành như thế này: Trông nó không được đẹp lắm nhỉ 🤔\nMình thì muốn label của selected item hiển thị ở dưới vùng có background màu trắng, và khi mình chọn một Bottom Navigation Bar item khác, label vẫn sẽ nằm yên ở đó. Vậy thì không còn cách nào khác là phải custom lại package này rồi. Đó là lúc chúng ta đến với bước 2 của bài viết này.\nCustom Curved Navigation Bar Mình quyết định tạo một package mới linh động hơn, có thể phù hợp với cả hai dạng là item có label và item không có label.\nTadaa\u0026hellip; Và đây là package của mình: curved_labeled_navigation_bar\nSau đây, mình sẽ hướng dẫn bạn cách implement của cả hai dạng.\nNavigation Bar có label Mình có tạo ra một Widget mới là CurvedNavigationBarItem để wrap cả Icon và label.\nCode example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bottomNavigationBar: CurvedNavigationBar( items: [ CurvedNavigationBarItem( child: Icon(Icons.home_outlined), label: \u0026#39;Home\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.search), label: \u0026#39;Search\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.chat_bubble_outline), label: \u0026#39;Chat\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.newspaper), label: \u0026#39;Feed\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.perm_identity), label: \u0026#39;Personal\u0026#39;, ), ], ) UI demo:\nNavigation Bar không có label Code example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bottomNavigationBar: CurvedNavigationBar( items: [ CurvedNavigationBarItem( child: Icon(Icons.home_outlined), ), CurvedNavigationBarItem( child: Icon(Icons.search), ), CurvedNavigationBarItem( child: Icon(Icons.chat_bubble_outline), ), CurvedNavigationBarItem( child: Icon(Icons.newspaper), ), CurvedNavigationBarItem( child: Icon(Icons.perm_identity), ), ], ) UI demo:\nLời kết Hy vọng package nhỏ này của mình giúp ích được cho những bạn đang muốn có một Bottom Navigation Bar khác lạ. Bạn có thể ủng hộ tinh thần mình bằng cách tặng mình một like, share nhé. Nếu bạn có ý tưởng gì để mình có thể cải thiện hơn nữa thì cũng đừng ngần ngại chia sẻ với mình.\nLink package: https://pub.dev/packages/curved_labeled_navigation_bar Github: https://github.com/namanh11611/curved_labeled_navigation_bar Mình chân thành cảm ơn!\n","date":"2022-10-17T22:36:00+07:00","image":"https://namanh11611.github.io/p/curved-bottom-navigation-bar/navigation_hu9904548229839369520.jpeg","permalink":"https://namanh11611.github.io/p/curved-bottom-navigation-bar/","title":"Custom Curved Bottom Navigation Bar trong Flutter"},{"content":"Đặt vấn đề Khi bạn muốn sạc iPhone bằng cáp type C =\u0026gt; hãy dùng một cái Adapter mà có lỗ type C và đầu lightning.\nKhi bạn đang dùng data dưới dạng XML, nhưng lại muốn sử dụng một function của third party library mà nó chỉ nhận param là JSON =\u0026gt; hãy dùng Adapter để convert XML sang JSON.\nTrong Android, bạn có một list item và muốn hiển thị nó lên RecyclerView =\u0026gt; hãy dùng Adapter để convert data lên từng item_view.\nKhái niệm Adapter pattern cho phép interface của một class đã có sẵn được dùng như là một interface khác. Nó sẽ giúp class đã tồn tại đó làm việc với những thằng khác mà không thay đổi source code.\nNghe vẫn hơi trừu tượng đúng không nhỉ? Chúng ta sẽ từ từ đi bóc tách hết cái lớp vỏ ngoài khó hiểu này nhé.\nTuy nhiên thì có 2 cách dùng adapter là Object Adapter và Class Adapter. Chúng ta sẽ cùng đi tìm hiểu chi tiết từng cách.\nObject Adapter Pattern Sơ đồ lớp Chúng ta sẽ implement interface bằng cách uỷ quyền tới object adaptee lúc run-time.\nMình sẽ giải thích chi tiết thêm một chút:\nClient là class đã có sẵn mà mình nhắc đến trong phần khái niệm nhé. Client Interface giờ là interface cha của Client. Những thằng khác muốn giao tiếp Client thì phải follow thằng interface cha này nhé. Service là một thằng third party mà chỉ nhận param là JSON như mình đặt vấn đề. Adapter implement Client Interface và chứa instance của class Service (object adaptee). Mỗi khi gọi đến method của Adapter, nó sẽ gọi đến method của Service này. Như vậy chúng ta đã có thể làm việc với thằng Service mà không cần sửa code ở Client. Code sample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Client Interface interface TypeCPhone { void chargeByTypeC(); } // Interface của Service interface LightningPhone { void chargeByLightning(); } // Service class IPhone implements LightningPhone { @Override public void chargeByLightning() {} } // Adapter class TypeCToLightningPhoneAdapter implements TypeCPhone { private LightningPhone lightningPhone; public TypeCToLightningPhoneAdapter(LightningPhone lightningPhone) { this.lightningPhone = lightningPhone; } @Override public void chargeByTypeC() { lightningPhone.chargeByLightning(); } } public class Demo { static void chargeMyXiaomiPhone(TypeCPhone phone) { phone.chargeByTypeC(); } public static void main(String[] args) { IPhone iPhone = new IPhone(); TypeCToLightningPhoneAdapter adapter = new TypeCToLightningPhoneAdapter(iPhone); chargeMyXiaomiPhone(adapter); } } Class Adapter pattern Class Adapter thì không cần wrap object nào cả vì nó kế thừa từ cả Client và Service.\nRất tiếc là Java không support đa kế thừa nên chúng ta không có code sample bằng Java cho phần này.\nKết luận Adapter là một design pattern khá quen thuộc với chúng ta. Qua phần giải thích và một chút code mẫu, mong mọi người hiểu thêm về nó.\nReference\nhttps://en.wikipedia.org/wiki/Adapter_pattern https://refactoring.guru/design-patterns/adapter ","date":"2022-10-04T22:50:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-adapter/adapter_hu9410201267739609711.jpeg","permalink":"https://namanh11611.github.io/p/design-pattern-adapter/","title":"Design Pattern: Adapter - làm thế nào để sạc iPhone bằng cáp type C"},{"content":"Bài viết này mình sẽ đi thẳng vào giải thích cách dùng các annotation @Inject, @Provides và @Binds. Vậy nên bỏ qua phần giải thích về Dependency Injection hay giới thiệu về Hilt. Coi như mọi người đã biết cách dùng nó rồi nhé. Chiến thôi!!!\nTổng quan Chúng ta có 3 annotation thường dùng để inject các object trong Hilt:\n@Inject: annotation dùng ở constructor của class @Provides: annotation dùng ở Module @Binds: một annotation khác cũng dùng ở Module Câu hỏi đặt ra là vậy khi nào thì dùng những thằng này nhỉ?\nInject Chúng ta dùng @Inject annotation ở tất cả các constructor mà mình cần inject object, từ ViewModel, Repository đến DataSource. Ví dụ:\n1 2 3 4 5 class ProfileRepository @Inject constructor( private val profileDataSource: ProfileDataSource ) { fun doSomething() {} } Việc này giúp chúng ta dễ dàng inject tiếp ProfileRepository vào các class khác, ví dụ như ViewModel hoặc UseCase. Tuy nhiên thì chúng ta lại chỉ có thể sử dụng annotation này để annotate constructor của những class mà mình tự define.\nProvides Vậy thì để khắc phục điểm yếu trên, inject object của những class mà mình không define (Ví dụ như Retrofit, OkHttpClient hoặc Room database), chúng ta cùng đến với @Provides. Trước tiên, chúng ta cần tạo một @Module để chứa các dependency với annotation @Provides. Ví dụ:\n1 2 3 4 5 6 7 8 9 10 @Module class NetworkModule { @Provides fun providesApiService(): ApiService = Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(BASE_URL) .build() .create(ApiService::class.java) } Vì Retrofit khởi tạo object không phải code của chúng ta define, thêm nữa lại còn khởi tạo theo kiểu Builder pattern, nên chúng ta không thể dùng @Inject annotation mà bắt buộc phải dùng @Provides. Bây giờ, chúng ta đã có thể inject object của interface ApiService ở bất cứ đâu.\nBinds Đối với interface, chúng ta không thể dùng annotation @Inject, vì nó không có constructor function. Tuy nhiên, nếu bạn có một interface mà chỉ có duy nhất một implementation (một class implement interface đó), thì bạn có thể dùng @Binds để inject interface đó. Việc inject interface thay vì class là một good practice, giúp dễ dàng test hơn.\nQuay trở lại với ProfileRepository ở phần @Inject, chúng ta sẽ biến nó thành một interface, và tạo một class implement interface đó. Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface ProfileRepository { } class ProfileRepositoryImpl @Inject constructor( private val profileDataSource: ProfileDataSource ) : ProfileRepository { } @Module @InstallIn(SingletonComponent::class) abstract class RepositoryModule { @Singleton @Binds abstract fun bindProfileRepository(profileRepository: ProfileRepositoryImpl): ProfileRepository } class RegisterUseCase @Inject constructor( private val profileRepository: ProfileRepository ) Ưu điểm của việc dùng @Binds thay cho @Provides là nó giúp giảm lượng code được generate, như là Module Factory class. Ở đây bạn có thể thấy mình vẫn dùng @Inject, bởi vì constructor function của ProfileRepositoryImpl vẫn cần một số parameter.\nTổng kết Vậy tóm gọn lại là\nDùng @Inject cho code của bạn Dùng @Provides cho code của bên thứ 3 Dùng @Binds cho inject interface, giúp giảm lượng code không cần thiết Reference\nhttps://developer.android.com/training/dependency-injection/hilt-android https://dagger.dev/hilt https://www.valueof.io/blog/inject-provides-binds-dependencies-dagger-hilt ","date":"2022-10-02T01:33:00+07:00","image":"https://namanh11611.github.io/p/hilt/hilt_hu11432902201496672808.jpeg","permalink":"https://namanh11611.github.io/p/hilt/","title":"Khi nào nên dùng Inject, Provides, Binds trong Hilt"},{"content":"Lời mở đầu Team mình đợt này đang triển khai chương trình mỗi tuần một bài học, nghĩa là mỗi tuần một người trong team sẽ lên seminar cho mọi người về 1 kỹ thuật hoặc công nghệ gì đấy. Anh em vừa trải qua mấy tuần mới đi hết Kotlin. Tuần vừa rồi anh teamlead seminar về Flask. Oh, sao mình thấy thằng này build API nhanh gọn, đơn giản thế, đúng tinh thần của Python. Lâu nay mình chỉ code Front-end với Mobile, chưa đụng Back-end bao giờ (Thực ra là hồi Sinh viên làm PHP nhưng quên hết rồi :joy::joy:). Thế là mình cũng về thử bắt tay làm ngay một chú xem thế nào.\nSetup Basic Về IDE, tối ưu nhất có lẽ là PyCharm. Nhưng cài nó cũng khá nặng nên mình tận dụng máy đang có sẵn Visual Studio Code, chỉ cần cài thêm extension Python là đủ để chiến.\nTrước tiên là cài Python rồi.\nNếu bạn dùng Windows thì link tải ở đây: Download Python.\nCòn mình dùng Ubuntu nên chỉ cần gõ:\n1 2 $ sudo apt-get update $ sudo apt-get install python3.9 Option Bạn có thể setup Virtual environments hoặc không, bạn có thể bỏ qua bước này. Virtual environments có tác dụng quản lý các dependencies của project. Ví dụ bạn có thể cài 1 lib với 2 version khác nhau cho 2 project khác nhau, thậm chí là Python version khác nhau. Mỗi project sẽ có 1 bộ Python libraries riêng biệt, không thằng nào ảnh hưởng đến thằng nào.\nPython3 sử dụng module venv để tạo Virtual environments. Bạn có thể thực hiện lệnh sau để tạo folder cho project và venv folder luôn:\n1 2 3 $ mkdir myproject $ cd myproject $ python3 -m venv venv Trên Windows:\n1 $ py -3 -m venv venv Run environment của bạn:\n1 $ . venv/bin/activate Flask Sau đó là cài Flask:\n1 $ pip install Flask Code thôi Hello World Bắt tay vào để code 1 ứng dụng Flask đơn giản nhất nào. Tạo 1 file hello.py (tên gì cũng được, miễn là tránh flask.py để tránh conflict) và code những dòng đầu tiên:\n1 2 3 4 5 6 from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def hello_world(): return \u0026#39;Hello, World!\u0026#39; Giải thích một chút:\nFlask(__name__) có tác dụng tạo 1 instance của class Flask. route() thì sẽ chỉ cho chúng ta URL của API. Run app luôn và ngay:\n1 2 $ export FLASK_APP=hello.py $ flask run Check http://127.0.0.1:5000/ để xem app của bạn đã chạy rồi này.\nNhưng giờ mỗi lần bạn sửa code, refresh browser vẫn chưa thấy code được apply. Thế là thế nào nhỉ??? Đó là vì bạn cần bật Debug mode lên nữa.\n1 2 $ export FLASK_ENV=development $ flask run Bây giờ thì thử sửa code và xem thành quả của bạn nào.\nBạn cũng có thể xem kết quả của mình trên thiết bị khác (ở đây mình muốn xem trên máy Android) bằng cách thay đổi host (địa chỉ host là IP của laptop/PC bạn đang dùng) và kết nối 2 máy tới cùng 1 mạng wifi:\n1 $ flask run --host=192.168.xxx.xxx JSON JSON là dạng dữ liệu mà mình hay dùng cho các API. Thử demo một chút JSON xem nào. Đầu tiên là cần import thêm jsonify:\n1 from flask import Flask, jsonify Thay vì return Hello, World!, chúng ta sẽ return kết quả trả về dưới dạng JSON:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @app.route(\u0026#39;/\u0026#39;) def hello_world(): return jsonify([ { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;First Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is first Memory\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Second Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is second Memory\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;title\u0026#34;: \u0026#34;Third Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is third Memory\u0026#34; } ]) Nhưng mình thấy các field bị đảo lộn hết cả lên, vậy thì phải thêm một chút config:\n1 app.config[\u0026#39;JSON_SORT_KEYS\u0026#39;] = False Ok, có vẻ ổn hơn rồi đấy!\nNgrok - demo app không cần deploy Mình là dev Android nên muốn thử xem Flask có dùng làm API cho Retrofit trong Android được không. Thế mà config như trên, máy nhận được API rồi nhưng khi apply vào Retrofit thì vẫn không được. Không hiểu có phải do http không? Nhờ các cao nhân giải đáp giúp đoạn này.\nVậy nên mình sẽ giới thiện với các bạn Ngrok, một công cụ giúp bạn nhanh chóng demo app Flask mà không cần deploy lên server.\nCài đặt ngrok:\n1 $ pip install pyngrok Run lệnh $ ngrok --help để chắc chắn rằng chúng ta đã cài đặt thành công. Sửa code một chút để tạo Ngrok Tunnel nào:\n1 2 3 4 from pyngrok import ngrok ... url = ngrok.connect(5000).public_url print(\u0026#39;Henzy Tunnel URL:\u0026#39;, url) Tiếp tục run $ flask run để xem kết quả. Check url được print ra và truy cập trên máy Android. Thử thay vào Url của Retrofit (nhớ dùng https) thì mình thấy nó chạy khá ổn.\nLời kết Trên đây mới là hướng dẫn Quickstart. Nếu các bạn có hứng thú, mình sẽ viết tiếp các bài tiếp theo.\nCảm ơn các bạn đã đọc!\nTham khảo:\nhttps://flask.palletsprojects.com/en/1.1.x/quickstart/#quickstart https://blog.miguelgrinberg.com/post/access-localhost-from-your-phone-or-from-anywhere-in-the-world ","date":"2021-01-14T01:03:00+07:00","image":"https://namanh11611.github.io/p/flask/flask_hu8807404152423008299.jpeg","permalink":"https://namanh11611.github.io/p/flask/","title":"Xây dựng API đơn giản với Flask, demo với Ngrok"},{"content":"Lời mở đầu Singleton pattern có lẽ là design pattern đơn giản nhất mà hầu như ai cũng biết. Nó giúp tạo một instance duy nhất của class, thường dùng để tạo các class cho Database, Manager\u0026hellip; Hôm nay mình đọc code của project đang làm thì phát hiện ra một cách khởi tạo Singleton hay quá, tìm hiểu thì nó gọi là Bill Pugh Singleton, lấy theo tên của tác giả nghĩ ra cách này. Vậy nên mình viết bài này chia sẻ cho mọi người một cách tiếp cận với Singleton.\nLazy Initialization Đầu tiên, chúng ta nhìn qua cách khởi tạo Singleton mà đa số mọi người đang dùng. Singleton pattern được implement bằng cách tạo một instance trong một public method. Cách này có nhược điểm là khi chạy ở multiple threads thì có thể bị khởi tạo instance nhiều lần. Lúc đó thì Singleton không còn là Singleton nữa rồi.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class LazyInitializedSingleton { private static LazyInitializedSingleton instance; private LazyInitializedSingleton() { } public static LazyInitializedSingleton getInstance() { if (instance == null) { instance = new LazyInitializedSingleton(); } return instance; } } Thread Safe Singleton Để khắc phục nhược điểm của Lazy Initialization, chúng ta thêm synchronized vào public method. Khi đó, chỉ có một instance được khởi tạo bởi một thread tại một thời điểm.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton() { } public static synchronized ThreadSafeSingleton getInstance() { if (instance == null) { instance = new ThreadSafeSingleton(); } return instance; } } Tuy nhiên, cách trên vẫn có nhược điểm là làm giảm hiệu năng của app khi mỗi lần gọi vì getInstance() là một synchronized method. Vậy nên chúng ta có 1 cách khác bổ sung như sau.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton() { } public static ThreadSafeSingleton getInstance() { if (instance == null) { synchronized (ThreadSafeSingleton.class) { if (instance == null) { instance = new ThreadSafeSingleton(); } } } return instance; } } Như vậy, chúng ta chỉ tốn sức trong lần gọi getInstance() đầu tiên.\nBill Pugh Singleton Implementation Trước Java 5, java memory có rất nhiều issue và các cách trên đều fail khi có quá nhiều thread gọi method getInstance() của Singleton class đồng thời. Vì vậy, Bill Pugh đưa ra một cách triển khai Singleton mới bằng cách sử dụng inner static helper class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class BillPughSingleton { private static class SingletonHelper { static final BillPughSingleton INSTANCE = new BillPughSingleton(); } private BillPughSingleton() { } public static BillPughSingleton getInstance() { return SingletonHelper.INSTANCE; } } Mọi người thấy cách này thế nào? Quá nhanh, quá gọn mà vẫn an toàn. Khi Singleton class được load, SingletonHelper class sẽ vẫn chưa được load vào memory. Chỉ khi method getInstance() được gọi, helper class mới được load và tạo singleton class instance. Cách này cũng không yêu cầu synchronization và check null nhiều lần.\nLời kết Trong khuôn khổ bài viết, còn một số phương pháp nữa mà mình không liệt kê hết được, chỉ mang đến góc nhìn mới về Singleton pattern cho mọi người. Cảm ơn mọi người đã đọc!\nTham khảo: https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples\n","date":"2020-12-29T15:00:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-singleton/singleton_hu14691199705639971088.jpeg","permalink":"https://namanh11611.github.io/p/design-pattern-singleton/","title":"Design Pattern: Bill Pugh Singleton trong Java - đơn giản đến không ngờ"},{"content":"Lời mở đầu Trải qua một thời gian đi làm, lang bạt qua vài công ty, mình nhận thấy ở mỗi nơi lại có quy trình làm việc với Git khác nhau. Bài viết này giới thiệu quy trình làm việc với Git mà mình nghĩ là chuẩn chỉ và cũng đang áp dụng ở công ty hiện tại. Vậy nên, mình sẽ không giới thiệu hết các lệnh Git, mà chỉ lướt qua những lệnh mình nghĩ đủ dùng cho quá trình làm việc của các bạn ở công ty.\nQuy trình Ngày đầu tiên đi làm Đơn giản quá nhỉ, ngày đầu tiên đi làm thì còn lệnh gì ngoài git clone nữa cơ chứ. Khi bạn muốn lấy source của team về, thì chỉ cần mở terminal, gõ:\n1 git clone \u0026lt;url\u0026gt; Thêm 1 típ nhỏ, là nếu bạn muốn tên folder sau khi clone về khác tên project trên remote thì hãy đặt tên folder ở cuối lệnh:\n1 git clone \u0026lt;url\u0026gt; folder_name Những ngày bình thường Một mình một ngựa Sếp giao một feature mới, bắt tay vào làm thôi nào. Khoan đã, nếu bạn đang ở 1 branch khác, đừng quên checkout về branch chính của team (thường branch chính sẽ đặt tên là master):\n1 git checkout master Rồi pull code mới nhất về:\n1 git pull Để kiểm tra code ở local đã update chưa, bạn hãy thử kiểm tra bằng git log. Mình thì thường dùng lệnh này để xem cho gọn:\n1 git log --oneline Sau đó, checkout ra một branch mới để bắt đầu làm feature của bạn. Thêm param -b sẽ giúp bạn tạo branch mới và checkout sang đó luôn:\n1 git checkout -b feature_branch \u0026hellip;\nCode\u0026hellip; code\u0026hellip; code\u0026hellip;\u0026hellip;\n\u0026hellip;\nXong rồi, bây giờ thì bắt đầu add những file bạn đã sửa vào stage. Thường thì các IDE hiện tại đều support bạn add và commit nhanh hơn, nhưng nếu bạn vẫn muốn gõ tay thì hãy gõ:\n1 git add . Lệnh vừa rồi đã giúp bạn add tất cả những file vừa sửa vào stage. Sau đó thì commit:\n1 git commit -m \u0026#34;Fix all bugs\u0026#34; Note: Cách đặt tên branch và commit cũng nên rõ ràng, thể hiện branch đó, commit đó thực hiện feature gì hay là fix bug gì. Điều này hoàn toàn phụ thuộc vào rules của từng team. Có những team đặt tiền tố là ID của task, nhưng có team lại đặt tiền tố là mục đích của commit đó là gì, ví dụ như feature/fixbug/\u0026hellip;\nVà cuối cùng là push code lên repository:\n1 git push origin feature_branch Bây giờ thì lên repository, tạo merge request cho sếp review. Trong lúc đó thì tranh thủ đi làm cốc coffee để chờ bước tiếp theo.\nFeature nhiều người làm Nếu branch của bạn có nhiều người làm chung, bạn chưa kịp push code thì đã có người khác push trước. Vậy thì trước khi push thì hãy pull theo cách này:\n1 git pull --rebase Commit của bạn sẽ được đẩy lên trên commit của đồng nghiệp trong log.\nTrong trường hợp bạn muốn lấy code về nhưng chưa muốn merge thì hãy dùng lệnh:\n1 git fetch Theo mình thì pull = fetch + merge.\nMerge code Sau một hồi review thì sếp cũng đồng ý cho bạn merge code, nhưng vấn đề là trong quá trình review thì bạn có thêm một vài commit để thêm, sửa, xóa file. Bạn muốn rebase những commit đó lại thành 1, hoặc đơn giản chỉ muốn sửa tên hay xóa commit nào đó. Giả sử bạn có 3 commit cần hợp nhất:\n1 git rebase -i HEAD~3 Terminal hiện ra cho bạn khá nhiều option như edit, reword, squash\u0026hellip; Thay chữ pick ở đầu dòng bằng option tương ứng mà bạn muốn dùng. Sau đó bấm Ctrl + O để ghi đè, tiếp tục Ctrl + X để thoát.\nCòn một vấn đề nữa là branch master đã có người khác push thêm code. Bạn vẫn có thể merge, nhưng nó sẽ tạo thêm 1 commit merge. Vậy nên mình thường sẽ rebase và merge fast forward. Đầu tiên, vẫn là:\n1 git fetch Sau đó là lệnh rebase. Bạn vẫn phải đứng ở feature_branch để thực hiện lệnh này:\n1 git rebase origin/master Nói một cách dễ hiểu, lệnh rebase sẽ giúp bạn lấy những code mới nhất từ branch master về, sau đó \u0026ldquo;viết lại\u0026rdquo; branch feature của bạn để đẩy commit của bạn lên trên cùng. Cuối cùng là push force lên feature branch. Push force sẽ apply toàn bộ log ở local của bạn lên branch ở repo, bất chấp log 2 nơi khác nhau:\n1 git push -f origin feature_branch Nếu branch một mình bạn làm thì có thể push force thoải mái. Nhưng hãy cân nhắc cẩn thận khi push force lên branch có nhiều người làm chung, vì nó sẽ dễ gây conflict cho người khác. Chỉ làm điều này khi bạn đã chắc chắn hoàn thành feature của mình.\nSau đó, merge code ở merge request trên repo. Vậy là bạn đã hoàn thành xuất sắc task đầu tiên rồi.\nNhững ngày khủng hoảng Reset Thực ra thì trong quá trình làm có thể bạn có nhầm lẫn gì đó mà cần revert code. Git reset sẽ có 3 option dành cho bạn.\nReset commit nhưng code vẫn ở trong stage, sẵn sàng cho bạn commit lại:\n1 git reset --soft commit_id Reset commit và đẩy code ra khỏi stage. Bạn cần dùng git add trước khi có thể commit lại:\n1 git reset --mixed commit_id Reset commit và xóa toàn bộ code bạn đã làm:\n1 git reset --hard commit_id Stash Bạn có thể dùng cái này như một cứu cánh để lưu tạm code trước khi thực hiện các lệnh rebase hay checkout sang branch khác mà bị conflict. Bạn cứ tưởng tượng nó như một tờ giấy nháp lưu theo cấu trúc stack vậy.\nKhi muốn lưu tất cả những thay đổi hiện tại vào stash:\n1 git stash Khi muốn apply stash cuối cùng vừa lưu:\n1 git stash pop Hiện tại mình đang dùng chủ yếu Android Studio, và nó có sẵn Shelf với chức năng tương tự nên hiện tại không còn dùng đến git stash.\nBạn có thể tham khảo thêm ở đây.\nKết Thực ra cái tiêu đề chỉ giật tít câu view thôi chứ không có gì là chuẩn chỉ cả. Vì quy trình của mỗi công ty là khác nhau, yêu cầu của dự án là khác nhau. Nếu dự án bạn ít người, cần ưu tiên tốc độ làm việc thì có thể bỏ bớt quy trình, push thẳng code lên master. Còn nếu dự án của bạn có nhiều người cùng làm, yêu cầu quy trình khắt khe thì có thể không cho push force lên remote chẳng hạn. Vậy quy trình của công ty của bạn thế nào? Cùng chia sẻ với mình nhé.\nThanks for reading!\n","date":"2020-11-10T17:19:00+07:00","image":"https://namanh11611.github.io/p/git-process/git_hu12566570037337430276.jpeg","permalink":"https://namanh11611.github.io/p/git-process/","title":"Quy trình làm việc chuẩn chỉ với Git"},{"content":"Hoàn cảnh đáng thương Chắc hẳn các lập trình viên JavaScript thì không còn xa lạ gì Date, đối tượng dùng để nhẩm ngày, đếm tháng, tính năm. Vào một ngày đẹp trời 29/3/2019, đang OT một cách vui vẻ và đầy hào hứng, tôi bỗng phát hiện ra một bug liên quan đến hiển thị ngày tháng trên Front-end. Ủa, hàm này truyền tham số là 1 thì trả về Mar (tháng 3), truyền tham số là 0 thì trả về Jan (tháng 1), trong khi kết quả mình muốn nhận là Feb (tháng 2). Chơi gì kỳ vậy???\nNhẹ nhàng bật F12 lên và debug thì phát hiện ra nguyên nhân là do hàm Date.getMonth() trả về kết quả kỳ cục như vậy.\nLúc ấy cũng đã 9h tối, không còn tin vào sự tỉnh táo của mình nên tôi chuyển qua tab Console để gõ thử xem liệu kết quả như thế nào? Liệu có phải do hàm getMonth() trong project bị ông nào custom rồi không? Và kết quả nhận được như sau (kết quả được tái hiện lại vào sáng 30/3): Các bạn có thể gõ thử trên console của mình để kiểm chứng:\n1 2 3 4 5 var date = new Date(); date.setMonth(1); date.getMonth(); date.setMonth(0); date.getMonth(); Bẫy chuột này lớn quá Hoá ra là sau khi gọi hàm setMonth(1), date không được set thành tháng 2 (index = 1) mà chỉ bị lùi đi 28 ngày (từ ngày 30/3 thành ngày 2/3) Các bạn có thể tham khảo thông tin về hàm setMonth() tại đây.\nĐọc kỹ phần Description, chúng ta mới thấy rằng hàm setMonth() sẽ dùng chính ngày hiện tại của tháng cũ để set ngày cho tháng mới, nếu vượt quá ngày của tháng mới thì sẽ cộng tiếp sang ngày của tháng tiếp theo. Ví dụ, ngày hiện tại là 30, 31 thì setMonth(1) chắc chắn sẽ bị tính sang tháng 3, vì tháng 2 chỉ có tối đa 29 ngày. Ở đây, ngày hiện tại của chúng ta là 30/3, thế nên khi set về tháng 2/2019 (có 28 ngày) sẽ bị tính thêm 2 ngày là thành ngày 2/3.\nQuả thật, cái bẫy chuột này ít nhất đã bẫy được một con chuột béo là mình rồi.\nGiải pháp Từ đó, chúng ta rút ra rằng, để setMonth(), getMonth() được thoải mái nhất, tốt nhất là nên dùng ngày mùng 1.\n1 var date = new Date(\u0026#39;March 1, 2019 00:00:01\u0026#39;); Lúc đó thì chúng ta có thể thoải mái setMonth(), getMonth() theo ý mình.\nChúc các bạn luôn đọc kỹ document và code ít bug. Đừng dính bẫy như mình.\n","date":"2019-03-30T01:33:00+07:00","image":"https://namanh11611.github.io/p/date-set-month/month_hu14208692164401242166.jpeg","permalink":"https://namanh11611.github.io/p/date-set-month/","title":"Cái bẫy chuột trong hàm Date.setMonth() của Javascript"}]